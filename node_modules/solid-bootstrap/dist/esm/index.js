import { createComponent, mergeProps as mergeProps$1, Dynamic, spread, template, insert, memo, className, effect, setAttribute, delegateEvents, style as style$1, isServer, use, addEventListener as addEventListener$1 } from 'solid-js/web';
import { createContext, createMemo, useContext, splitProps, mergeProps, createSignal, children, Show, createComputed, batch, createEffect, onCleanup, createSelector, For } from 'solid-js';
import { resolveClasses, callEventHandler, createControlledProp, Anchor, ModalManager, useButtonProps, useDropdownItem, useDropdownMenu, DropdownContext as DropdownContext$2, useDropdownToggle, Dropdown as Dropdown$2, useNavItem, makeEventKey, Nav as Nav$2, Modal as Modal$2, SelectableContext, Overlay as Overlay$2, Tabs as Tabs$2, useTabPanel, TabContext } from 'solid-bootstrap-core';
export { Anchor } from 'solid-bootstrap-core';
import { Transition, EXITED, EXITING, ENTERING, ENTERED, UNMOUNTED } from 'solid-react-transition';

// Source: https://github.com/lukeed/clsx/blob/master/src/index.js
function toVal(mix) {
  var k,
      y,
      str = "";

  if (typeof mix === "string" || typeof mix === "number") {
    str += mix;
  } else if (typeof mix === "object") {
    if (Array.isArray(mix)) {
      for (k = 0; k < mix.length; k++) {
        if (mix[k]) {
          if (y = toVal(mix[k])) {
            str && (str += " ");
            str += y;
          }
        }
      }
    } else {
      for (k in mix) {
        if (mix[k]) {
          str && (str += " ");
          str += k;
        }
      }
    }
  }

  return str;
}

function classNames (...classes) {
  var i = 0,
      tmp,
      x,
      str = "";

  while (i < classes.length) {
    if (tmp = classes[i++]) {
      if (x = toVal(tmp)) {
        str && (str += " ");
        str += x;
      }
    }
  }

  return str;
}

const DEFAULT_BREAKPOINTS = ["xxl", "xl", "lg", "md", "sm", "xs"];
const ThemeContext = createContext({
  prefixes: {},
  breakpoints: DEFAULT_BREAKPOINTS
});

function ThemeProvider({
  prefixes = {},
  breakpoints = DEFAULT_BREAKPOINTS,
  dir,
  children
}) {
  const contextValue = createMemo(() => ({
    prefixes: { ...prefixes
    },
    breakpoints,
    dir
  }));
  return createComponent(ThemeContext.Provider, {
    get value() {
      return contextValue();
    },

    children: children
  });
}

function useBootstrapPrefix(prefix, defaultPrefix) {
  const themeContext = useContext(ThemeContext);
  return prefix || themeContext.prefixes[defaultPrefix] || defaultPrefix;
}
function useBootstrapBreakpoints() {
  const ctx = useContext(ThemeContext);
  return () => ctx.breakpoints;
}
function useIsRTL() {
  const ctx = useContext(ThemeContext);
  return () => ctx.dir === "rtl";
}

/**
 * Returns the owner document of a given element.
 * 
 * @param node the element
 */
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}

/**
 * Returns the owner window of a given element.
 * 
 * @param node the element
 */

function ownerWindow(node) {
  var doc = ownerDocument(node);
  return doc && doc.defaultView || window;
}

/**
 * Returns one or all computed style properties of an element.
 * 
 * @param node the element
 * @param psuedoElement the style property
 */

function getComputedStyle$1(node, psuedoElement) {
  return ownerWindow(node).getComputedStyle(node, psuedoElement);
}

var rUpper = /([A-Z])/g;
function hyphenate(string) {
  return string.replace(rUpper, '-$1').toLowerCase();
}

/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 * https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/vendor/core/hyphenateStyleName.js
 */
var msPattern = /^ms-/;
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

var supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;
function isTransform(value) {
  return !!(value && supportedTransforms.test(value));
}

function style(node, property) {
  var css = '';
  var transforms = '';

  if (typeof property === 'string') {
    return node.style.getPropertyValue(hyphenateStyleName(property)) || getComputedStyle$1(node).getPropertyValue(hyphenateStyleName(property));
  }

  Object.keys(property).forEach(function (key) {
    var value = property[key];

    if (!value && value !== 0) {
      node.style.removeProperty(hyphenateStyleName(key));
    } else if (isTransform(key)) {
      transforms += key + "(" + value + ") ";
    } else {
      css += hyphenateStyleName(key) + ": " + value + ";";
    }
  });

  if (transforms) {
    css += "transform: " + transforms + ";";
  }

  node.style.cssText += ";" + css;
}

// source https://github.com/react-bootstrap/react-bootstrap/blob/f11723114d532cfce840417834a73733a8436414/src/triggerBrowserReflow.tsx
// reading a dimension prop will cause the browser to recalculate,
// which will let our animations work
function triggerBrowserReflow(node) {
  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
  node.offsetHeight;
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/* eslint-disable no-return-assign */
var optionsSupported = false;
var onceSupported = false;

try {
  var options = {
    get passive() {
      return optionsSupported = true;
    },

    get once() {
      // eslint-disable-next-line no-multi-assign
      return onceSupported = optionsSupported = true;
    }

  };

  if (canUseDOM) {
    window.addEventListener('test', options, options);
    window.removeEventListener('test', options, true);
  }
} catch (e) {
  /* */
}
/**
 * An `addEventListener` ponyfill, supports the `once` option
 * 
 * @param node the element
 * @param eventName the event name
 * @param handle the handler
 * @param options event options
 */


function addEventListener(node, eventName, handler, options) {
  if (options && typeof options !== 'boolean' && !onceSupported) {
    var once = options.once,
        capture = options.capture;
    var wrappedHandler = handler;

    if (!onceSupported && once) {
      wrappedHandler = handler.__once || function onceHandler(event) {
        this.removeEventListener(eventName, onceHandler, capture);
        handler.call(this, event);
      };

      handler.__once = wrappedHandler;
    }

    node.addEventListener(eventName, wrappedHandler, optionsSupported ? options : capture);
  }

  node.addEventListener(eventName, handler, options);
}

/**
 * A `removeEventListener` ponyfill
 * 
 * @param node the element
 * @param eventName the event name
 * @param handle the handler
 * @param options event options
 */
function removeEventListener(node, eventName, handler, options) {
  var capture = options && typeof options !== 'boolean' ? options.capture : options;
  node.removeEventListener(eventName, handler, capture);

  if (handler.__once) {
    node.removeEventListener(eventName, handler.__once, capture);
  }
}

function listen(node, eventName, handler, options) {
  addEventListener(node, eventName, handler, options);
  return function () {
    removeEventListener(node, eventName, handler, options);
  };
}

/**
 * Triggers an event on a given element.
 * 
 * @param node the element
 * @param eventName the event name to trigger
 * @param bubbles whether the event should bubble up
 * @param cancelable whether the event should be cancelable
 */
function triggerEvent(node, eventName, bubbles, cancelable) {
  if (bubbles === void 0) {
    bubbles = false;
  }

  if (cancelable === void 0) {
    cancelable = true;
  }

  if (node) {
    var event = document.createEvent('HTMLEvents');
    event.initEvent(eventName, bubbles, cancelable);
    node.dispatchEvent(event);
  }
}

function parseDuration$1(node) {
  var str = style(node, 'transitionDuration') || '';
  var mult = str.indexOf('ms') === -1 ? 1000 : 1;
  return parseFloat(str) * mult;
}

function emulateTransitionEnd(element, duration, padding) {
  if (padding === void 0) {
    padding = 5;
  }

  var called = false;
  var handle = setTimeout(function () {
    if (!called) triggerEvent(element, 'transitionend', true);
  }, duration + padding);
  var remove = listen(element, 'transitionend', function () {
    called = true;
  }, {
    once: true
  });
  return function () {
    clearTimeout(handle);
    remove();
  };
}

function transitionEnd(element, handler, duration, padding) {
  if (duration == null) duration = parseDuration$1(element) || 0;
  var removeEmulate = emulateTransitionEnd(element, duration, padding);
  var remove = listen(element, 'transitionend', handler);
  return function () {
    removeEmulate();
    remove();
  };
}

// source https://github.com/react-bootstrap/react-bootstrap/blob/f11723114d532cfce840417834a73733a8436414/src/transitionEndListener.ts

function parseDuration(node, property) {
  const str = style(node, property) || "";
  const mult = str.indexOf("ms") === -1 ? 1000 : 1;
  return parseFloat(str) * mult;
}

function transitionEndListener(element, handler) {
  const duration = parseDuration(element, "transitionDuration");
  const delay = parseDuration(element, "transitionDelay");
  const remove = transitionEnd(element, e => {
    if (e.target === element) {
      remove();
      handler(e);
    }
  }, duration + delay);
}

const defaultProps$1d = {}; // Normalizes Transition callbacks when nodeRef is used.

const TransitionWrapper = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$1d, p), ["onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "addEndListener", "children", "childRef"]);
  let [nodeRef, setNodeRef] = createSignal();

  const mergedRef = ref => {
    setNodeRef(ref);
    local.childRef?.(ref);
  };

  function normalize(callback) {
    return param => {
      if (callback && nodeRef()) {
        callback(nodeRef(), param);
      }
    };
  }

  const handlers = {
    get onEnter() {
      return normalize(local.onEnter);
    },

    get onEntering() {
      return normalize(local.onEntering);
    },

    get onEntered() {
      return normalize(local.onEntered);
    },

    get onExit() {
      return normalize(local.onExit);
    },

    get onExiting() {
      return normalize(local.onExiting);
    },

    get onExited() {
      return normalize(local.onExited);
    },

    get addEndListener() {
      return normalize(local.addEndListener);
    }

  };
  const resolvedChildren = children(() => local.children);

  function renderChild() {
    const child = resolvedChildren();

    if (typeof child === "function") {
      // wrap function to get ref
      return (status, innerProps) => child(status, { ...innerProps,
        ref: mergedRef
      });
    } else {
      // get resolved ref now
      mergedRef(child);
      return child;
    }
  }

  return createComponent(Transition, mergeProps$1(props, handlers, {
    get nodeRef() {
      return nodeRef();
    },

    get children() {
      return renderChild();
    }

  }));
};

var TransitionWrapper$1 = TransitionWrapper;

const MARGINS = {
  height: ["marginTop", "marginBottom"],
  width: ["marginLeft", "marginRight"]
};

function getDefaultDimensionValue(dimension, elem) {
  const offset = `offset${dimension[0].toUpperCase()}${dimension.slice(1)}`;
  const value = elem[offset];
  const margins = MARGINS[dimension];
  return value + // @ts-ignore
  parseInt(style(elem, margins[0]), 10) + // @ts-ignore
  parseInt(style(elem, margins[1]), 10);
}

const collapseStyles = {
  [EXITED]: "collapse",
  [EXITING]: "collapsing",
  [ENTERING]: "collapsing",
  [ENTERED]: "collapse show",
  [UNMOUNTED]: ""
};
const defaultProps$1c = {
  in: false,
  dimension: "height",
  timeout: 300,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  getDimensionValue: getDefaultDimensionValue
};

const Collapse = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$1c, p), ["onEnter", "onEntering", "onEntered", "onExit", "onExiting", "class", "children", "dimension", "getDimensionValue"]);
  /* Compute dimension */

  const computedDimension = () => typeof local.dimension === "function" ? local.dimension() : local.dimension;
  /* -- Expanding -- */


  const handleEnter = elem => {
    elem.style[computedDimension()] = "0";
    local.onEnter?.(elem);
  };

  const handleEntering = elem => {
    const scroll = `scroll${computedDimension()[0].toUpperCase()}${computedDimension().slice(1)}`;
    elem.style[computedDimension()] = `${elem[scroll]}px`;
    local.onEntering?.(elem);
  };

  const handleEntered = elem => {
    // @ts-ignore
    elem.style[computedDimension()] = null;
    local.onEntered?.(elem);
  };
  /* -- Collapsing -- */


  const handleExit = elem => {
    elem.style[computedDimension()] = `${local.getDimensionValue(computedDimension(), elem)}px`; // @ts-ignore

    triggerBrowserReflow(elem);
    local.onExit?.(elem);
  };

  const handleExiting = elem => {
    // @ts-ignore
    elem.style[computedDimension()] = null;
    local.onExiting?.(elem);
  };

  const resolvedChildren = children(() => local.children);
  let prevClasses;
  return createComponent(TransitionWrapper$1, mergeProps$1({
    addEndListener: transitionEndListener
  }, props, {
    get ["aria-expanded"]() {
      return props.role ? props.in : null;
    },

    onEnter: handleEnter,
    onEntering: handleEntering,
    onEntered: handleEntered,
    onExit: handleExit,
    onExiting: handleExiting,
    children: (state, innerProps) => {
      const el = resolvedChildren();
      innerProps.ref(el);
      const newClasses = classNames(local.class, collapseStyles[state], computedDimension() === "width" && "collapse-horizontal");
      resolveClasses(el, prevClasses, newClasses);
      prevClasses = newClasses;
      return el;
    }
  }));
};

var Collapse$1 = Collapse;

// ported from https://github.com/react-bootstrap/react-bootstrap/blob/f11723114d532cfce840417834a73733a8436414/src/AccordionContext.ts
function isAccordionItemSelected(activeEventKey, eventKey) {
  return Array.isArray(activeEventKey) ? activeEventKey.includes(eventKey) : activeEventKey === eventKey;
}
const context$4 = createContext({});
var AccordionContext = context$4;

const defaultProps$1b = {
  as: "div"
};

const AccordionCollapse = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$1b, p), ["as", "bsPrefix", "class", "children", "eventKey"]);
  const context = useContext(AccordionContext);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "accordion-collapse");
  return createComponent(Collapse$1, mergeProps$1({
    get ["in"]() {
      return isAccordionItemSelected(context.activeEventKey, local.eventKey);
    }

  }, props, {
    get children() {
      return createComponent(Dynamic, {
        get component() {
          return local.as;
        },

        get ["class"]() {
          return classNames(local.class, bsPrefix);
        },

        get children() {
          return local.children;
        }

      });
    }

  }));
};

var AccordionCollapse$1 = AccordionCollapse;

// ported from https://github.com/react-bootstrap/react-bootstrap/blob/f11723114d532cfce840417834a73733a8436414/src/AccordionContext.ts
const context$3 = createContext({
  eventKey: ""
});
var AccordionItemContext = context$3;

const defaultProps$1a = {
  as: "div"
};

const AccordionBody = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$1a, p), ["as", "bsPrefix", "class"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "accordion-body");
  const context = useContext(AccordionItemContext);
  return createComponent(AccordionCollapse$1, {
    get eventKey() {
      return context.eventKey;
    },

    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }

      }, props, {
        get ["class"]() {
          return classNames(local.class, bsPrefix);
        }

      }));
    }

  });
};

var AccordionBody$1 = AccordionBody;

function useAccordionButton(eventKey, onClick) {
  const context = useContext(AccordionContext);
  return e => {
    /*
      Compare the event key in context with the given event key.
      If they are the same, then collapse the component.
    */
    let eventKeyPassed = eventKey === context.activeEventKey ? null : eventKey;

    if (context.alwaysOpen) {
      if (Array.isArray(context.activeEventKey)) {
        if (context.activeEventKey.includes(eventKey)) {
          eventKeyPassed = context.activeEventKey.filter(k => k !== eventKey);
        } else {
          eventKeyPassed = [...context.activeEventKey, eventKey];
        }
      } else {
        // activeEventKey is undefined.
        eventKeyPassed = [eventKey];
      }
    }

    context.onSelect?.(eventKeyPassed, e);
    callEventHandler(onClick, e);
  };
}
const defaultProps$19 = {
  as: "button"
};

const AccordionButton = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$19, p), ["as", "bsPrefix", "class", "onClick"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "accordion-button");
  const itemContext = useContext(AccordionItemContext);
  const accordionOnClick = useAccordionButton(itemContext.eventKey, local.onClick);
  const accordionContext = useContext(AccordionContext);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },

    onClick: accordionOnClick
  }, props, {
    get type() {
      return local.as === "button" ? "button" : undefined;
    },

    get ["aria-expanded"]() {
      return itemContext.eventKey === accordionContext.activeEventKey;
    },

    get ["class"]() {
      return classNames(local.class, bsPrefix, !isAccordionItemSelected(accordionContext.activeEventKey, itemContext.eventKey) && "collapsed");
    }

  }));
};

var AccordionButton$1 = AccordionButton;

const defaultProps$18 = {
  as: "h2"
};

const AccordionHeader = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$18, p), ["as", "bsPrefix", "class", "children", "onClick"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "accordion-header");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, bsPrefix);
    },

    get children() {
      return createComponent(AccordionButton$1, {
        get onClick() {
          return local.onClick;
        },

        get children() {
          return local.children;
        }

      });
    }

  }));
};

var AccordionHeader$1 = AccordionHeader;

const defaultProps$17 = {
  as: "div"
};

const AccordionItem = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$17, p), ["as", "bsPrefix", "class", "eventKey"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "accordion-item");
  const contextValue = {
    get eventKey() {
      return local.eventKey;
    }

  };
  return createComponent(AccordionItemContext.Provider, {
    value: contextValue,

    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }

      }, props, {
        get ["class"]() {
          return classNames(local.class, bsPrefix);
        }

      }));
    }

  });
};

var AccordionItem$1 = AccordionItem;

const defaultProps$16 = {
  as: "div"
};

const Accordion = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$16, p), ["as", "activeKey", "alwaysOpen", "bsPrefix", "class", "defaultActiveKey", "onSelect", "flush"]);
  const [activeKey, onSelect] = createControlledProp(() => local.activeKey, () => local.defaultActiveKey, local.onSelect);
  const prefix = useBootstrapPrefix(local.bsPrefix, "accordion");
  const contextValue = {
    get activeEventKey() {
      return activeKey();
    },

    get alwaysOpen() {
      return local.alwaysOpen;
    },

    get onSelect() {
      return onSelect;
    }

  };
  return createComponent(AccordionContext.Provider, {
    value: contextValue,

    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }

      }, props, {
        get ["class"]() {
          return classNames(local.class, prefix, local.flush && `${prefix}-flush`);
        }

      }));
    }

  });
};

var Accordion$1 = Object.assign(Accordion, {
  Button: AccordionButton$1,
  Collapse: AccordionCollapse$1,
  Item: AccordionItem$1,
  Header: AccordionHeader$1,
  Body: AccordionBody$1
});

const defaultProps$15 = {
  in: false,
  timeout: 300,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false
};
const fadeStyles$1 = {
  [ENTERING]: "show",
  [ENTERED]: "show"
};

const Fade = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$15, p), ["class", "children", "transitionClasses"]);

  const handleEnter = (node, isAppearing) => {
    triggerBrowserReflow(node);
    props.onEnter?.(node, isAppearing);
  };

  let resolvedChildren;
  let prevClasses;
  return createComponent(TransitionWrapper$1, mergeProps$1({
    addEndListener: transitionEndListener,
    onEnter: handleEnter
  }, props, {
    children: (status, innerProps) => {
      // lazily resolve children first time to avoid hydration errors
      if (!resolvedChildren) resolvedChildren = children(() => local.children);
      let el = resolvedChildren();

      while (typeof el === "function") el = el();

      innerProps.ref(el);
      const newClasses = classNames("fade", local.class, // @ts-ignore
      fadeStyles$1?.[status], local.transitionClasses?.[status]);
      resolveClasses(el, prevClasses, newClasses);
      prevClasses = newClasses;
      return el;
    }
  }));
};

var Fade$1 = Fade;

const _tmpl$$r = /*#__PURE__*/template(`<button type="button"></button>`, 2);
const defaultProps$14 = {
  "aria-label": "Close"
};

const CloseButton = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$14, p), ["class", "variant"]);
  return (() => {
    const _el$ = _tmpl$$r.cloneNode(true);

    spread(_el$, mergeProps$1({
      get ["class"]() {
        return classNames("btn-close", local.variant && `btn-close-${local.variant}`, local.class);
      }

    }, props), false, false);

    return _el$;
  })();
};

var CloseButton$1 = CloseButton;

const _tmpl$$q = /*#__PURE__*/template(`<div></div>`, 2);
const divWithClass = c => p => {
  return (() => {
    const _el$ = _tmpl$$q.cloneNode(true);

    spread(_el$, mergeProps$1(p, {
      get ["class"]() {
        return classNames(p.class, c);
      }

    }), false, false);

    return _el$;
  })();
};

// TODO: emstricten & fix the typing here! `createWithBsPrefix<TElementType>...`
function createWithBsPrefix(prefix, {
  Component,
  defaultProps = {}
} = {}) {
  const BsComponent = p => {
    const [local, props] = splitProps(mergeProps({
      as: Component
    }, defaultProps, p), ["class", "bsPrefix", "as"]);
    const resolvedPrefix = useBootstrapPrefix(local.bsPrefix, prefix);
    return createComponent(Dynamic, mergeProps$1({
      get component() {
        return local.as || "div";
      },

      get ["class"]() {
        return classNames(local.class, resolvedPrefix);
      }

    }, props));
  };

  return BsComponent;
}

const _tmpl$$p = /*#__PURE__*/template(`<div role="alert"></div>`, 2);
const DivStyledAsH4$1 = divWithClass("h4");
const AlertHeading = createWithBsPrefix("alert-heading", {
  Component: DivStyledAsH4$1
});
const AlertLink = createWithBsPrefix("alert-link", {
  Component: Anchor
});
const defaultProps$13 = {
  variant: "primary",
  defaultShow: true,
  transition: Fade$1,
  closeLabel: "Close alert"
};

const Alert = uncontrolledProps => {
  const [local, props] = splitProps(mergeProps(defaultProps$13, uncontrolledProps), ["bsPrefix", "children", "defaultShow", "show", "closeLabel", "closeVariant", "class", "children", "variant", "onClose", "dismissible", "transition"]);
  const [show, onClose] = createControlledProp(() => local.show, () => local.defaultShow, local.onClose);
  const prefix = useBootstrapPrefix(local.bsPrefix, "alert");

  const handleClose = e => {
    if (onClose) {
      onClose(false, e);
    }
  };

  const Transition = local.transition === true ? Fade$1 : local.transition;

  const alert = () => (() => {
    const _el$ = _tmpl$$p.cloneNode(true);

    spread(_el$, mergeProps$1(!Transition ? props : {}, {
      get ["class"]() {
        return classNames(local.class, prefix, local.variant && `${prefix}-${local.variant}`, local.dismissible && `${prefix}-dismissible`);
      }

    }), false, true);

    insert(_el$, (() => {
      const _c$ = memo(() => !!local.dismissible);

      return () => _c$() && createComponent(CloseButton$1, {
        onClick: handleClose,

        get ["aria-label"]() {
          return local.closeLabel;
        },

        get variant() {
          return local.closeVariant;
        }

      });
    })(), null);

    insert(_el$, () => local.children, null);

    return _el$;
  })();

  return createComponent(Show, {
    when: !!Transition,

    get fallback() {
      return local.show ? alert : null;
    },

    get children() {
      return createComponent(Transition, mergeProps$1({
        unmountOnExit: true
      }, props, {
        ref(r$) {
          undefined = r$;
        },

        get ["in"]() {
          return show();
        },

        children: alert
      }));
    }

  });
};

var Alert$1 = Object.assign(Alert, {
  Link: AlertLink,
  Heading: AlertHeading
});

const defaultProps$12 = {
  as: "span",
  bg: "primary",
  pill: false
};

const Badge = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$12, p), ["as", "bsPrefix", "bg", "pill", "text", "class"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "badge");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, prefix, local.pill && `rounded-pill`, local.text && `text-${local.text}`, local.bg && `bg-${local.bg}`);
    }

  }));
};

var Badge$1 = Badge;

/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}

var toArray = Function.prototype.bind.call(Function.prototype.call, [].slice);
/**
 * Runs `querySelectorAll` on a given element.
 * 
 * @param element the element
 * @param selector the selector
 */

function qsa(element, selector) {
  return toArray(element.querySelectorAll(selector));
}

function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}

const Selector = {
  FIXED_CONTENT: ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
  STICKY_CONTENT: ".sticky-top",
  NAVBAR_TOGGLER: ".navbar-toggler"
};
class BootstrapModalManager extends ModalManager {
  adjustAndStore(prop, element, adjust) {
    const actual = element.style[prop]; // TODO: DOMStringMap and CSSStyleDeclaration aren't strictly compatible
    // @ts-ignore

    element.dataset[prop] = actual;
    style(element, {
      [prop]: `${parseFloat(style(element, prop)) + adjust}px`
    });
  }

  restore(prop, element) {
    // @ts-ignore
    const value = element.dataset[prop];

    if (value !== undefined) {
      // @ts-ignore
      delete element.dataset[prop];
      style(element, {
        [prop]: value
      });
    }
  }

  setContainerStyle(containerState) {
    super.setContainerStyle(containerState);
    const container = this.getElement();
    addClass(container, "modal-open");
    if (!containerState.scrollBarWidth) return;
    const paddingProp = this.isRTL ? "paddingLeft" : "paddingRight";
    const marginProp = this.isRTL ? "marginLeft" : "marginRight";
    qsa(container, Selector.FIXED_CONTENT).forEach(el => this.adjustAndStore(paddingProp, el, containerState.scrollBarWidth));
    qsa(container, Selector.STICKY_CONTENT).forEach(el => this.adjustAndStore(marginProp, el, -containerState.scrollBarWidth));
    qsa(container, Selector.NAVBAR_TOGGLER).forEach(el => this.adjustAndStore(marginProp, el, containerState.scrollBarWidth));
  }

  removeContainerStyle(containerState) {
    super.removeContainerStyle(containerState);
    const container = this.getElement();
    removeClass(container, "modal-open");
    const paddingProp = this.isRTL ? "paddingLeft" : "paddingRight";
    const marginProp = this.isRTL ? "marginLeft" : "marginRight";
    qsa(container, Selector.FIXED_CONTENT).forEach(el => this.restore(paddingProp, el));
    qsa(container, Selector.STICKY_CONTENT).forEach(el => this.restore(marginProp, el));
    qsa(container, Selector.NAVBAR_TOGGLER).forEach(el => this.restore(marginProp, el));
  }

}
let sharedManager;
function getSharedManager(options) {
  if (!sharedManager) sharedManager = new BootstrapModalManager(options);
  return sharedManager;
}
var BootstrapModalManager$1 = BootstrapModalManager;

const defaultProps$11 = {
  as: "li",
  active: false,
  linkAs: Anchor,
  linkProps: {}
};

const BreadcrumbItem = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$11, p), ["bsPrefix", "active", "children", "class", "as", "linkAs", "linkProps", "href", "title", "target"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "breadcrumb-item");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(prefix, local.class, {
        active: local.active
      });
    },

    get ["aria-current"]() {
      return local.active ? "page" : undefined;
    },

    get children() {
      return memo(() => !!local.active)() ? local.children : createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.linkAs;
        }

      }, () => local.linkProps, {
        get href() {
          return local.href;
        },

        get title() {
          return local.title;
        },

        get target() {
          return local.target;
        },

        get children() {
          return local.children;
        }

      }));
    }

  }));
};

var BreadcrumbItem$1 = BreadcrumbItem;

const _tmpl$$o = /*#__PURE__*/template(`<ol></ol>`, 2);
const defaultProps$10 = {
  as: "nav",
  label: "breadcrumb",
  listProps: {}
};

const Breadcrumb = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$10, p), ["bsPrefix", "class", "listProps", "children", "label", "as"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "breadcrumb");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },

    get ["aria-label"]() {
      return local.label;
    },

    get ["class"]() {
      return classNames(local.class);
    }

  }, props, {
    get children() {
      const _el$ = _tmpl$$o.cloneNode(true);

      spread(_el$, mergeProps$1(() => local.listProps, {
        get ["class"]() {
          return classNames(prefix, local.listProps?.class);
        }

      }), false, true);

      insert(_el$, () => local.children);

      return _el$;
    }

  }));
};

var Breadcrumb$1 = Object.assign(Breadcrumb, {
  Item: BreadcrumbItem$1
});

const defaultProps$$ = {
  variant: "primary",
  active: false,
  disabled: false
};

const Button = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$$, p), ["as", "bsPrefix", "children", "variant", "size", "active", "class"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "btn");
  const [buttonProps, {
    tagName
  }] = useButtonProps({
    tagName: local.as,
    ...props
  });
  return createComponent(Dynamic, mergeProps$1({
    component: tagName
  }, buttonProps, props, {
    get ["class"]() {
      return classNames(local.class, prefix, local.active && "active", local.variant && `${prefix}-${local.variant}`, local.size && `${prefix}-${local.size}`, props.href && props.disabled && "disabled");
    },

    get children() {
      return local.children;
    }

  }));
};

var Button$1 = Button;

const defaultProps$_ = {
  as: "div",
  vertical: false,
  role: "group"
};

const ButtonGroup = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$_, p), ["bsPrefix", "size", "vertical", "class", "as"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "btn-group");
  let baseClass = prefix;
  if (local.vertical) baseClass = `${prefix}-vertical`;
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, baseClass, local.size && `${prefix}-${local.size}`);
    }

  }));
};

var ButtonGroup$1 = ButtonGroup;

const _tmpl$$n = /*#__PURE__*/template(`<div></div>`, 2);
const defaultProps$Z = {
  role: "toolbar"
};

const ButtonToolbar = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$Z, p), ["bsPrefix", "class"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "btn-toolbar");
  return (() => {
    const _el$ = _tmpl$$n.cloneNode(true);

    spread(_el$, mergeProps$1(props, {
      get ["class"]() {
        return classNames(local.class, prefix);
      }

    }), false, false);

    return _el$;
  })();
};

var ButtonToolbar$1 = ButtonToolbar;

const defaultProps$Y = {
  as: "img"
};

const CardImg = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$Y, p), ["as", "bsPrefix", "class", "variant"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "card-img");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },

    get ["class"]() {
      return classNames(local.variant ? `${prefix}-${local.variant}` : prefix, local.class);
    }

  }, props));
};

var CardImg$1 = CardImg;

const context$2 = createContext(null);
var CardHeaderContext = context$2;

const defaultProps$X = {
  as: "div"
};

const CardHeader = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$X, p), ["as", "bsPrefix", "class"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "card-header");
  const contextValue = {
    get cardHeaderBsPrefix() {
      return prefix;
    }

  };
  return createComponent(CardHeaderContext.Provider, {
    value: contextValue,

    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }

      }, props, {
        get ["class"]() {
          return classNames(local.class, prefix);
        }

      }));
    }

  });
};

var CardHeader$1 = CardHeader;

const DivStyledAsH5$1 = divWithClass("h5");
const DivStyledAsH6 = divWithClass("h6");
const CardBody = createWithBsPrefix("card-body");
const CardTitle = createWithBsPrefix("card-title", {
  Component: DivStyledAsH5$1
});
const CardSubtitle = createWithBsPrefix("card-subtitle", {
  Component: DivStyledAsH6
});
const CardLink = createWithBsPrefix("card-link", {
  Component: "a"
});
const CardText = createWithBsPrefix("card-text", {
  Component: "p"
});
const CardFooter = createWithBsPrefix("card-footer");
const CardImgOverlay = createWithBsPrefix("card-img-overlay");
const defaultProps$W = {
  as: "div",
  body: false
};

const Card = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$W, p), ["as", "bsPrefix", "class", "bg", "text", "border", "body", "children"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "card");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, prefix, local.bg && `bg-${local.bg}`, local.text && `text-${local.text}`, local.border && `border-${local.border}`);
    },

    get children() {
      return memo(() => !!local.body)() ? createComponent(CardBody, {
        get children() {
          return local.children;
        }

      }) : local.children;
    }

  }));
};

var Card$1 = Object.assign(Card, {
  Img: CardImg$1,
  Title: CardTitle,
  Subtitle: CardSubtitle,
  Body: CardBody,
  Link: CardLink,
  Text: CardText,
  Header: CardHeader$1,
  Footer: CardFooter,
  ImgOverlay: CardImgOverlay
});

var CardGroup = createWithBsPrefix("card-group");

var CarouselCaption = createWithBsPrefix("carousel-caption");

const defaultProps$V = {
  as: "div"
};

const CarouselItem = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$V, p), ["as", "bsPrefix", "class", "interval"]); // custom response to allow <Carousel /> to access interval

  return {
    item: createComponent(Dynamic, mergeProps$1({
      get component() {
        return local.as;
      }

    }, props, {
      get ["class"]() {
        return classNames(local.class, useBootstrapPrefix(local.bsPrefix, "carousel-item"));
      }

    })),
    interval: local.interval
  };
};

var CarouselItem$1 = CarouselItem;

const _tmpl$$m = /*#__PURE__*/template(`<div></div>`, 2),
      _tmpl$2$5 = /*#__PURE__*/template(`<button type="button" data-bs-target=""></button>`, 2),
      _tmpl$3$1 = /*#__PURE__*/template(`<span aria-hidden="true" class="carousel-control-prev-icon"></span>`, 2),
      _tmpl$4 = /*#__PURE__*/template(`<span class="visually-hidden"></span>`, 2),
      _tmpl$5 = /*#__PURE__*/template(`<span aria-hidden="true" class="carousel-control-next-icon"></span>`, 2);
const SWIPE_THRESHOLD = 40;
const defaultProps$U = {
  as: "div",
  slide: true,
  fade: false,
  controls: true,
  indicators: true,
  indicatorLabels: [],
  defaultActiveIndex: 0,
  interval: 5000,
  keyboard: true,
  pause: "hover",
  wrap: true,
  touch: true,
  prevLabel: "Previous",
  nextLabel: "Next"
};

function isVisible(element) {
  if (!element || !element.style || !element.parentNode || // @ts-ignore
  !element.parentNode.style) {
    return false;
  }

  const elementStyle = getComputedStyle(element);
  return elementStyle.display !== "none" && elementStyle.visibility !== "hidden" && getComputedStyle(element.parentNode).display !== "none";
}

const Carousel = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$U, p), ["as", "bsPrefix", "slide", "fade", "controls", "indicators", "indicatorLabels", "activeIndex", "defaultActiveIndex", "onSelect", "onSlide", "onSlid", "interval", "keyboard", "onKeyDown", "pause", "onMouseOver", "onMouseOut", "wrap", "touch", "onTouchStart", "onTouchMove", "onTouchEnd", "prevIcon", "prevLabel", "nextIcon", "nextLabel", "variant", "class", "children", "ref"]);
  const [activeIndex, onSelect] = createControlledProp(() => local.activeIndex, () => local.defaultActiveIndex, local.onSelect);
  const prefix = useBootstrapPrefix(local.bsPrefix, "carousel");
  const isRTL = useIsRTL();
  const resolvedChildren = children(() => local.children);
  const items = createMemo(() => {
    const c = resolvedChildren();
    return Array.isArray(c) ? c : [c];
  });
  const [nextDirectionRef, setNextDirectionRef] = createSignal(null);
  const [direction, setDirection] = createSignal("next");
  const [paused, setPaused] = createSignal(false);
  const [isSliding, setIsSliding] = createSignal(false);
  const [renderedActiveIndex, setRenderedActiveIndex] = createSignal(activeIndex() || 0);
  createComputed(() => batch(() => {
    if (!isSliding() && activeIndex() !== renderedActiveIndex()) {
      if (nextDirectionRef()) {
        setDirection(nextDirectionRef());
      } else {
        setDirection((activeIndex() || 0) > renderedActiveIndex() ? "next" : "prev");
      }

      if (local.slide) {
        setIsSliding(true);
      }

      setRenderedActiveIndex(activeIndex() || 0);
    }
  }));
  createEffect(() => {
    if (nextDirectionRef()) {
      setNextDirectionRef(null);
    }
  }); // Iterate to grab all of the children's interval values
  // (and count them, too)

  const activeChildInterval = createMemo(() => {
    for (let index = 0; index < items().length; index++) {
      if (index === activeIndex()) {
        const item = items()[index];
        return item.interval;
      }
    }

    return undefined;
  });

  const prev = event => {
    if (isSliding()) {
      return;
    }

    let nextActiveIndex = renderedActiveIndex() - 1;

    if (nextActiveIndex < 0) {
      if (!local.wrap) {
        return;
      }

      nextActiveIndex = items().length - 1;
    }

    setNextDirectionRef("prev");
    onSelect?.(nextActiveIndex, event);
  }; // This is used in the setInterval, so it should not invalidate.


  const next = event => {
    if (isSliding()) {
      return;
    }

    let nextActiveIndex = renderedActiveIndex() + 1;

    if (nextActiveIndex >= items().length) {
      if (!local.wrap) {
        return;
      }

      nextActiveIndex = 0;
    }

    setNextDirectionRef("next");
    onSelect?.(nextActiveIndex, event);
  };

  const [elementRef, setElementRef] = createSignal();

  const mergedRef = ref => {
    setElementRef(ref);

    if (typeof local.ref === "function") {
      local.ref({
        get element() {
          return elementRef();
        },

        prev,
        next
      });
    }
  }; // This is used in the setInterval, so it should not invalidate.


  const nextWhenVisible = () => {
    if (!document.hidden && isVisible(elementRef())) {
      if (isRTL()) {
        prev();
      } else {
        next();
      }
    }
  };

  const slideDirection = createMemo(() => direction() === "next" ? "start" : "end");
  createEffect(() => {
    if (local.slide) {
      // These callbacks will be handled by the <Transition> callbacks.
      return;
    }

    local.onSlide?.(renderedActiveIndex(), slideDirection());
    local.onSlid?.(renderedActiveIndex(), slideDirection());
  });
  const orderClass = createMemo(() => `${prefix}-item-${direction()}`);
  const directionalClass = createMemo(() => `${prefix}-item-${slideDirection()}`);

  const handleEnter = node => {
    triggerBrowserReflow(node);
    local.onSlide?.(renderedActiveIndex(), slideDirection());
  };

  const handleEntered = () => {
    setIsSliding(false);
    local.onSlid?.(renderedActiveIndex(), slideDirection());
  };

  const handleKeyDown = event => {
    if (local.keyboard && !/input|textarea/i.test( //@ts-ignore
    event.target.tagName)) {
      switch (event.key) {
        case "ArrowLeft":
          event.preventDefault();

          if (isRTL()) {
            next(event);
          } else {
            prev(event);
          }

          return;

        case "ArrowRight":
          event.preventDefault();

          if (isRTL()) {
            prev(event);
          } else {
            next(event);
          }

          return;
      }
    }

    callEventHandler(local.onKeyDown, event);
  };

  const handleMouseOver = event => {
    if (local.pause === "hover") {
      setPaused(true);
    }

    callEventHandler(local.onMouseOver, event);
  };

  const handleMouseOut = event => {
    setPaused(false);
    callEventHandler(local.onMouseOut, event);
  };

  let touchStartXRef;
  let touchDeltaXRef;

  const handleTouchStart = event => {
    touchStartXRef = event.touches[0].clientX;
    touchDeltaXRef = 0;

    if (local.pause === "hover") {
      setPaused(true);
    }

    callEventHandler(local.onTouchStart, event);
  };

  const handleTouchMove = event => {
    if (event.touches && event.touches.length > 1) {
      touchDeltaXRef = 0;
    } else {
      touchDeltaXRef = event.touches[0].clientX - touchStartXRef;
    }

    callEventHandler(local.onTouchMove, event);
  };

  const handleTouchEnd = event => {
    if (local.touch) {
      const touchDeltaX = touchDeltaXRef;

      if (Math.abs(touchDeltaX) > SWIPE_THRESHOLD) {
        if (touchDeltaX > 0) {
          prev(event);
        } else {
          next(event);
        }
      }
    }

    if (local.pause === "hover") {
      let touchUnpauseTimeout = window.setTimeout(() => {
        setPaused(false);
      }, local.interval);
      onCleanup(() => {
        window.clearTimeout(touchUnpauseTimeout);
      });
    }

    callEventHandler(local.onTouchEnd, event);
  };

  const shouldPlay = createMemo(() => local.interval != null && !paused() && !isSliding());
  const [intervalHandleRef, setIntervalHandleRef] = createSignal();
  createEffect(() => {
    if (!shouldPlay()) {
      return undefined;
    }

    const nextFunc = isRTL() ? prev : next;
    setIntervalHandleRef(window.setInterval(document.visibilityState ? nextWhenVisible : nextFunc, activeChildInterval() ?? local.interval ?? undefined));
    onCleanup(() => {
      if (intervalHandleRef() !== null) {
        clearInterval(intervalHandleRef());
      }
    });
  });
  const isActive = createSelector(renderedActiveIndex);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },

    ref: mergedRef
  }, props, {
    onKeyDown: handleKeyDown,
    onMouseOver: handleMouseOver,
    onMouseOut: handleMouseOut,
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd,

    get ["class"]() {
      return classNames(local.class, prefix, local.slide && "slide", local.fade && `${prefix}-fade`, local.variant && `${prefix}-${local.variant}`);
    },

    get children() {
      return [memo(() => memo(() => !!local.indicators)() && (() => {
        const _el$2 = _tmpl$$m.cloneNode(true);

        className(_el$2, `${prefix}-indicators`);

        insert(_el$2, createComponent(For, {
          get each() {
            return items();
          },

          children: (_, index) => (() => {
            const _el$3 = _tmpl$2$5.cloneNode(true);

            _el$3.$$click = e => onSelect?.(index(), e);

            effect(_p$ => {
              const _v$ = local.indicatorLabels?.length ? local.indicatorLabels[index()] : `Slide ${index() + 1}`,
                    _v$2 = isActive(index()) ? "active" : undefined,
                    _v$3 = isActive(index());

              _v$ !== _p$._v$ && setAttribute(_el$3, "aria-label", _p$._v$ = _v$);
              _v$2 !== _p$._v$2 && className(_el$3, _p$._v$2 = _v$2);
              _v$3 !== _p$._v$3 && setAttribute(_el$3, "aria-current", _p$._v$3 = _v$3);
              return _p$;
            }, {
              _v$: undefined,
              _v$2: undefined,
              _v$3: undefined
            });

            return _el$3;
          })()
        }));

        return _el$2;
      })()), (() => {
        const _el$ = _tmpl$$m.cloneNode(true);

        className(_el$, `${prefix}-inner`);

        insert(_el$, createComponent(For, {
          get each() {
            return items();
          },

          children: (child, index) => {
            const el = typeof child.item === "function" ? child.item() : child.item;
            return local.slide ? createComponent(TransitionWrapper$1, {
              get ["in"]() {
                return isActive(index());
              },

              get onEnter() {
                return isActive(index()) ? handleEnter : undefined;
              },

              get onEntered() {
                return isActive(index()) ? handleEntered : undefined;
              },

              addEndListener: transitionEndListener,
              children: (status, innerProps) => {
                innerProps.ref(el);
                const newClasses = classNames(isActive(index()) && status !== "entered" && orderClass(), (status === "entered" || status === "exiting") && "active", (status === "entering" || status === "exiting") && directionalClass());
                resolveClasses(el, child.prevClasses, newClasses);
                child.prevClasses = newClasses;
                return el;
              }
            }) : () => {
              createEffect(() => {
                el.classList.toggle("active", isActive(index()));
              });
              return el;
            };
          }
        }));

        return _el$;
      })(), memo(() => memo(() => !!local.controls)() && [memo((() => {
        const _c$ = memo(() => !!(local.wrap || activeIndex() !== 0));

        return () => _c$() && createComponent(Anchor, {
          "class": `${prefix}-control-prev`,
          onClick: prev,

          get children() {
            return [memo(() => local.prevIcon ?? _tmpl$3$1.cloneNode(true)), memo(() => memo(() => !!local.prevLabel)() && (() => {
              const _el$5 = _tmpl$4.cloneNode(true);

              insert(_el$5, () => local.prevLabel);

              return _el$5;
            })())];
          }

        });
      })()), memo((() => {
        const _c$2 = memo(() => !!(local.wrap || activeIndex() !== items().length - 1));

        return () => _c$2() && createComponent(Anchor, {
          "class": `${prefix}-control-next`,
          onClick: next,

          get children() {
            return [memo(() => local.nextIcon ?? _tmpl$5.cloneNode(true)), memo(() => memo(() => !!local.nextLabel)() && (() => {
              const _el$7 = _tmpl$4.cloneNode(true);

              insert(_el$7, () => local.nextLabel);

              return _el$7;
            })())];
          }

        });
      })())])];
    }

  }));
};

var Carousel$1 = Object.assign(Carousel, {
  Caption: CarouselCaption,
  Item: CarouselItem$1
});

delegateEvents(["click"]);

const DEVICE_SIZES = ["xxl", "xl", "lg", "md", "sm", "xs"];
function useCol(o) {
  const [local, props] = splitProps(o, ["as", "bsPrefix", "class"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "col");
  const breakpoints = useBootstrapBreakpoints();
  const spans = [];
  const classes = [];
  breakpoints().forEach(brkPoint => {
    const propValue = props[brkPoint];
    let span;
    let offset;
    let order;

    if (typeof propValue === "object" && propValue != null) {
      ({
        span,
        offset,
        order
      } = propValue);
    } else {
      span = propValue;
    }

    const infix = brkPoint !== "xs" ? `-${brkPoint}` : "";
    if (span) spans.push(span === true ? `${bsPrefix}${infix}` : `${bsPrefix}${infix}-${span}`);
    if (order != null) classes.push(`order${infix}-${order}`);
    if (offset != null) classes.push(`offset${infix}-${offset}`);
  });
  const [_, cleanedProps] = splitProps(props, DEVICE_SIZES);
  return [mergeProps(cleanedProps, {
    get class() {
      return classNames(local.class, ...spans, ...classes);
    }

  }), {
    get as() {
      return local.as;
    },

    get bsPrefix() {
      return bsPrefix;
    },

    get spans() {
      return spans;
    }

  }];
}

const Col = p => {
  const [useProps, meta] = useCol(p);
  const [local, colProps] = splitProps(useProps, ["class"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return meta.as ?? "div";
    }

  }, colProps, {
    get ["class"]() {
      return classNames(local.class, !meta.spans.length && meta.bsPrefix);
    }

  }));
};

var Col$1 = Col;

const defaultProps$T = {
  as: "div",
  fluid: false
};

const Container = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$T, p), ["as", "bsPrefix", "fluid", "class"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "container");
  const suffix = typeof local.fluid === "string" ? `-${local.fluid}` : "-fluid";
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, local.fluid ? `${prefix}${suffix}` : prefix);
    }

  }));
};

var Container$1 = Container;

const DropdownContext = createContext({});
var DropdownContext$1 = DropdownContext;

const defaultProps$S = {
  as: Anchor,
  disabled: false
};

const DropdownItem = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$S, p), ["as", "bsPrefix", "class", "eventKey", "disabled", "onClick", "active"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "dropdown-item");
  const [dropdownItemProps, meta] = useDropdownItem({
    get key() {
      return local.eventKey;
    },

    get href() {
      return props.href;
    },

    get disabled() {
      return local.disabled;
    },

    get onClick() {
      return local.onClick;
    },

    get active() {
      return local.active;
    }

  });
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, dropdownItemProps, {
    get ["class"]() {
      return classNames(local.class, prefix, meta.isActive && "active", local.disabled && "disabled");
    }

  }));
};

var DropdownItem$1 = DropdownItem;

const context$1 = createContext(null);
var InputGroupContext = context$1;

const context = createContext(null);
var NavbarContext = context;

const defaultProps$R = {
  as: "div",
  flip: true
};
function getDropdownMenuPlacement(alignEnd, dropDirection, isRTL) {
  const topStart = isRTL ? "top-end" : "top-start";
  const topEnd = isRTL ? "top-start" : "top-end";
  const bottomStart = isRTL ? "bottom-end" : "bottom-start";
  const bottomEnd = isRTL ? "bottom-start" : "bottom-end";
  const leftStart = isRTL ? "right-start" : "left-start";
  const leftEnd = isRTL ? "right-end" : "left-end";
  const rightStart = isRTL ? "left-start" : "right-start";
  const rightEnd = isRTL ? "left-end" : "right-end";
  let placement = alignEnd ? bottomEnd : bottomStart;
  if (dropDirection === "up") placement = alignEnd ? topEnd : topStart;else if (dropDirection === "end") placement = alignEnd ? rightEnd : rightStart;else if (dropDirection === "start") placement = alignEnd ? leftEnd : leftStart;
  return placement;
}

const DropdownMenu = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$R, p), ["as", "bsPrefix", "class", "align", "rootCloseEvent", "flip", "show", "renderOnMount", "popperConfig", "ref", "variant"]);
  let alignEnd = false;
  const isNavbar = useContext(NavbarContext);
  const prefix = useBootstrapPrefix(local.bsPrefix, "dropdown-menu");
  const dropdownContext = useContext(DropdownContext$1);
  const align = local.align || dropdownContext.align;
  const isInputGroup = useContext(InputGroupContext);
  const alignClasses = [];

  if (align) {
    if (typeof align === "object") {
      const keys = Object.keys(align);

      if (keys.length) {
        const brkPoint = keys[0]; // @ts-ignore

        const direction = align[brkPoint]; // .dropdown-menu-end is required for responsively aligning
        // left in addition to align left classes.

        alignEnd = direction === "start";
        alignClasses.push(`${prefix}-${brkPoint}-${direction}`);
      }
    } else if (align === "end") {
      alignEnd = true;
    }
  }

  const [menuProps, menuMeta] = useDropdownMenu({
    get flip() {
      return local.flip;
    },

    get rootCloseEvent() {
      return local.rootCloseEvent;
    },

    get show() {
      return local.show;
    },

    get usePopper() {
      return !isNavbar && alignClasses.length === 0;
    },

    get offset() {
      return [0, 2];
    },

    get popperConfig() {
      return local.popperConfig;
    },

    get placement() {
      return getDropdownMenuPlacement(alignEnd, dropdownContext.drop, dropdownContext.isRTL);
    }

  });

  const mergedRef = ref => {
    menuProps.ref?.(ref);
    local.ref?.(ref);
  }; // createEffect(() => {
  //   // Popper's initial position for the menu is incorrect when
  //   // renderOnMount=true. Need to call update() to correct it.
  //   if (menuMeta.show) menuMeta.popper?.update();
  // });


  const extendedMenuProps = mergeProps(menuProps, // For custom components provide additional, non-DOM, props;
  typeof local.as !== "string" ? {
    get show() {
      return menuMeta.show;
    },

    get close() {
      return () => menuMeta.toggle?.(false);
    },

    get align() {
      return align;
    }

  } : {}); // we don't need the default popper style,
  // menus are display: none when not shown.

  const style = () => menuMeta.popper?.placement ? { ...props.style,
    ...menuProps.style
  } : props.style;

  return createComponent(Show, {
    get when() {
      return menuMeta.hasShown || local.renderOnMount || isInputGroup;
    },

    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }

      }, props, extendedMenuProps, {
        ref: mergedRef,

        get style() {
          return style();
        }

      }, () => alignClasses.length || isNavbar ? {
        "data-bs-popper": "static"
      } : {}, {
        get ["class"]() {
          return classNames(local.class, prefix, menuMeta.show && "show", alignEnd && `${prefix}-end`, local.variant && `${prefix}-${local.variant}`, ...alignClasses);
        }

      }));
    }

  });
};

var DropdownMenu$1 = DropdownMenu;

const defaultProps$Q = {
  as: Button$1
};

const DropdownToggle = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$Q, p), ["as", "bsPrefix", "split", "class", "childBsPrefix", "ref"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "dropdown-toggle");
  const dropdownContext = useContext(DropdownContext$2);
  const isInputGroup = useContext(InputGroupContext);

  if (local.childBsPrefix !== undefined) {
    props.bsPrefix = local.childBsPrefix;
  }

  const [toggleProps] = useDropdownToggle();
  const [toggleLocal, toggleOther] = splitProps(toggleProps, ["ref"]);

  const mergedRef = ref => {
    toggleLocal.ref?.(ref);
    local.ref?.(ref);
  }; // This intentionally forwards size and variant (if set) to the
  // underlying component, to allow it to render size and style variants.


  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },

    get ["class"]() {
      return classNames(local.class, prefix, local.split && `${prefix}-split`, !!isInputGroup && dropdownContext?.show && "show");
    }

  }, toggleOther, props, {
    ref: mergedRef
  }));
};

var DropdownToggle$1 = DropdownToggle;

const DropdownHeader = createWithBsPrefix("dropdown-header", {
  defaultProps: {
    role: "heading"
  }
});
const DropdownDivider = createWithBsPrefix("dropdown-divider", {
  Component: "hr",
  defaultProps: {
    role: "separator"
  }
});
const DropdownItemText = createWithBsPrefix("dropdown-item-text", {
  Component: "span"
});
const defaultProps$P = {
  as: "div",
  navbar: false,
  align: "start",
  autoClose: true
};

const Dropdown = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$P, p), ["as", "bsPrefix", "drop", "show", "defaultShow", "class", "align", "onSelect", "onToggle", "focusFirstItemOnShow", "navbar", "autoClose"]);
  const [show, onToggle] = createControlledProp(() => local.show, () => local.defaultShow, local.onToggle);
  const isInputGroup = useContext(InputGroupContext);
  const prefix = useBootstrapPrefix(local.bsPrefix, "dropdown");
  const isRTL = useIsRTL();

  const isClosingPermitted = source => {
    // autoClose=false only permits close on button click
    if (local.autoClose === false) return source === "click"; // autoClose=inside doesn't permit close on rootClose

    if (local.autoClose === "inside") return source !== "rootClose"; // autoClose=outside doesn't permit close on select

    if (local.autoClose === "outside") return source !== "select";
    return true;
  };

  const handleToggle = (nextShow, meta) => {
    if ( // null option below is for "bug?" in Solid returning null instead of document
    (meta.originalEvent.currentTarget === document || meta.originalEvent.currentTarget === null) && (meta.source !== "keydown" || meta.originalEvent.key === "Escape")) {
      meta.source = "rootClose";
    }

    if (isClosingPermitted(meta.source)) onToggle?.(nextShow, meta);
  };

  const alignEnd = local.align === "end";
  const placement = getDropdownMenuPlacement(alignEnd, local.drop, isRTL());
  const contextValue = {
    get align() {
      return local.align;
    },

    get drop() {
      return local.drop;
    },

    get isRTL() {
      return isRTL();
    }

  };
  return createComponent(DropdownContext$1.Provider, {
    value: contextValue,

    get children() {
      return createComponent(Dropdown$2, {
        placement: placement,

        get show() {
          return show();
        },

        get onSelect() {
          return local.onSelect;
        },

        onToggle: handleToggle,

        get focusFirstItemOnShow() {
          return local.focusFirstItemOnShow;
        },

        itemSelector: `.${prefix}-item:not(.disabled):not(:disabled)`,

        get children() {
          return isInputGroup ? props.children : createComponent(Dynamic, mergeProps$1({
            get component() {
              return local.as;
            }

          }, props, {
            get ["class"]() {
              return classNames(local.class, show() && "show", (!local.drop || local.drop === "down") && prefix, local.drop === "up" && "dropup", local.drop === "end" && "dropend", local.drop === "start" && "dropstart");
            }

          }));
        }

      });
    }

  });
};

var Dropdown$1 = Object.assign(Dropdown, {
  Toggle: DropdownToggle$1,
  Menu: DropdownMenu$1,
  Item: DropdownItem$1,
  ItemText: DropdownItemText,
  Divider: DropdownDivider,
  Header: DropdownHeader
});

const defaultProps$O = {};
/**
 * A convenience component for simple or general use dropdowns. Renders a `Button` toggle and all `children`
 * are passed directly to the default `Dropdown.Menu`. This component accepts all of
 * [`Dropdown`'s props](#dropdown-props).
 *
 * _All unknown props are passed through to the `Dropdown` component._ Only
 * the Button `variant`, `size` and `bsPrefix` props are passed to the toggle,
 * along with menu-related props are passed to the `Dropdown.Menu`
 */

const DropdownButton = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$O, p), ["title", "children", "bsPrefix", "rootCloseEvent", "variant", "size", "menuRole", "renderMenuOnMount", "disabled", "href", "id", "menuVariant"]);
  return createComponent(Dropdown$1, mergeProps$1(props, {
    get children() {
      return [createComponent(DropdownToggle$1, {
        get id() {
          return local.id;
        },

        get href() {
          return local.href;
        },

        get size() {
          return local.size;
        },

        get variant() {
          return local.variant;
        },

        get disabled() {
          return local.disabled;
        },

        get childBsPrefix() {
          return local.bsPrefix;
        },

        get children() {
          return local.title;
        }

      }), createComponent(DropdownMenu$1, {
        get role() {
          return local.menuRole;
        },

        get renderOnMount() {
          return local.renderMenuOnMount;
        },

        get rootCloseEvent() {
          return local.rootCloseEvent;
        },

        get variant() {
          return local.menuVariant;
        },

        get children() {
          return local.children;
        }

      })];
    }

  }));
};

var DropdownButton$1 = DropdownButton;

const defaultProps$N = {
  as: "div",
  type: "valid",
  tooltip: false
};

const Feedback = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$N, p), ["as", "class", "type", "tooltip"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, `${local.type}-${local.tooltip ? "tooltip" : "feedback"}`);
    }

  }));
};

var Feedback$1 = Feedback;

const _tmpl$$l = /*#__PURE__*/template(`<img>`, 1);
const defaultProps$M = {
  fluid: false,
  rounded: false,
  roundedCircle: false,
  thumbnail: false
};

const Image = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$M, p), ["bsPrefix", "class", "fluid", "rounded", "roundedCircle", "thumbnail"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "img");
  return (() => {
    const _el$ = _tmpl$$l.cloneNode(true);

    spread(_el$, mergeProps$1(props, {
      get ["class"]() {
        return classNames(local.class, local.fluid && `${bsPrefix}-fluid`, local.rounded && `rounded`, local.roundedCircle && `rounded-circle`, local.thumbnail && `${bsPrefix}-thumbnail`);
      }

    }), false, false);

    return _el$;
  })();
};

var Image$1 = Image;

const defaultProps$L = {
  fluid: true
};

const FigureImage = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$L, p), ["class"]);
  return createComponent(Image$1, mergeProps$1(props, {
    get ["class"]() {
      return classNames(local.class, "figure-img");
    }

  }));
};

var FigureImage$1 = FigureImage;

const FigureCaption = createWithBsPrefix("figure-caption", {
  Component: "figcaption"
});
var FigureCaption$1 = FigureCaption;

const Figure = createWithBsPrefix("figure", {
  Component: "figure"
});
var Figure$1 = Object.assign(Figure, {
  Image: FigureImage$1,
  Caption: FigureCaption$1
});

const FormContext = createContext({});
var FormContext$1 = FormContext;

const defaultProps$K = {
  as: "div"
};

const FormGroup = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$K, p), ["as", "controlId"]);
  const context = {
    get controlId() {
      return local.controlId;
    }

  };
  return createComponent(FormContext$1.Provider, {
    value: context,

    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }

      }, props));
    }

  });
};

var FormGroup$1 = FormGroup;

const _tmpl$$k = /*#__PURE__*/template(`<label></label>`, 2);
const defaultProps$J = {};

const FloatingLabel = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$J, p), ["bsPrefix", "class", "children", "controlId", "label"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "form-floating");
  return createComponent(FormGroup$1, mergeProps$1({
    get ["class"]() {
      return classNames(local.class, bsPrefix);
    },

    get controlId() {
      return local.controlId;
    }

  }, props, {
    get children() {
      return [memo(() => local.children), (() => {
        const _el$ = _tmpl$$k.cloneNode(true);

        insert(_el$, () => local.label);

        effect(() => setAttribute(_el$, "for", local.controlId));

        return _el$;
      })()];
    }

  }));
};

var FloatingLabel$1 = FloatingLabel;

const defaultProps$I = {
  as: "input",
  type: "checkbox",
  isValid: false,
  isInvalid: false
};

const FormCheckInput = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$I, p), ["as", "id", "bsPrefix", "class", "type", "isValid", "isInvalid"]);
  const formContext = useContext(FormContext$1);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "form-check-input");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get type() {
      return local.type;
    },

    get id() {
      return local.id || formContext.controlId;
    },

    get ["class"]() {
      return classNames(local.class, bsPrefix, local.isValid && "is-valid", local.isInvalid && "is-invalid");
    }

  }));
};

var FormCheckInput$1 = FormCheckInput;

const FormCheckContext = createContext();
var FormCheckContext$1 = FormCheckContext;

const _tmpl$$j = /*#__PURE__*/template(`<label></label>`, 2);
const defaultProps$H = {};

const FormCheckLabel = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$H, p), ["bsPrefix", "class", "for"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "form-check-label");
  const formContext = useContext(FormContext$1);
  const formCheckContext = useContext(FormCheckContext$1);
  formCheckContext?.setHasFormCheckLabel?.(true);
  return (() => {
    const _el$ = _tmpl$$j.cloneNode(true);

    spread(_el$, mergeProps$1(props, {
      get ["for"]() {
        return local.for || formContext.controlId;
      },

      get ["class"]() {
        return classNames(local.class, bsPrefix);
      }

    }), false, false);

    return _el$;
  })();
};

var FormCheckLabel$1 = FormCheckLabel;

const _tmpl$$i = /*#__PURE__*/template(`<div></div>`, 2);
const defaultProps$G = {
  as: "input",
  title: "",
  type: "checkbox",
  inline: false,
  disabled: false,
  isValid: false,
  isInvalid: false,
  feedbackTooltip: false
};

const FormCheck = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$G, p), ["as", "id", "bsPrefix", "bsSwitchPrefix", "inline", "disabled", "isValid", "isInvalid", "feedbackTooltip", "feedback", "feedbackType", "class", "style", "title", "type", "label", "children"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "form-check");
  const bsSwitchPrefix = useBootstrapPrefix(local.bsSwitchPrefix, "form-switch");
  const [hasFormCheckLabel, setHasFormCheckLabel] = createSignal(false);
  const formContext = useContext(FormContext$1);
  const innerFormContext = {
    get controlId() {
      return local.id || formContext.controlId;
    }

  };
  const resolvedChildren = children(() => local.children);
  const hasLabel = createMemo(() => local.label != null && local.label !== false && !resolvedChildren() || hasFormCheckLabel());
  return createComponent(FormContext$1.Provider, {
    value: innerFormContext,

    get children() {
      return createComponent(FormCheckContext$1.Provider, {
        value: {
          setHasFormCheckLabel
        },

        get children() {
          const _el$ = _tmpl$$i.cloneNode(true);

          insert(_el$, () => resolvedChildren() || [createComponent(FormCheckInput$1, mergeProps$1(props, {
            get type() {
              return local.type === "switch" ? "checkbox" : local.type;
            },

            get isValid() {
              return local.isValid;
            },

            get isInvalid() {
              return local.isInvalid;
            },

            get disabled() {
              return local.disabled;
            },

            get as() {
              return local.as;
            }

          })), memo((() => {
            const _c$ = memo(() => !!hasLabel());

            return () => _c$() && createComponent(FormCheckLabel$1, {
              get title() {
                return local.title;
              },

              get children() {
                return local.label;
              }

            });
          })()), memo((() => {
            const _c$2 = memo(() => !!local.feedback);

            return () => _c$2() && createComponent(Feedback$1, {
              get type() {
                return local.feedbackType;
              },

              get tooltip() {
                return local.feedbackTooltip;
              },

              get children() {
                return local.feedback;
              }

            });
          })())]);

          effect(_p$ => {
            const _v$ = local.style,
                  _v$2 = classNames(local.class, hasLabel() && bsPrefix, local.inline && `${bsPrefix}-inline`, local.type === "switch" && bsSwitchPrefix);

            _p$._v$ = style$1(_el$, _v$, _p$._v$);
            _v$2 !== _p$._v$2 && className(_el$, _p$._v$2 = _v$2);
            return _p$;
          }, {
            _v$: undefined,
            _v$2: undefined
          });

          return _el$;
        }

      });
    }

  });
};

var FormCheck$1 = Object.assign(FormCheck, {
  Input: FormCheckInput$1,
  Label: FormCheckLabel$1
});

const defaultProps$F = {
  as: "input",
  isValid: false,
  isInvalid: false
};

const FormControl = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$F, p), ["as", "bsPrefix", "type", "size", "htmlSize", "id", "class", "isValid", "isInvalid", "plaintext", "readOnly"]);
  const formContext = useContext(FormContext$1);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "form-control");

  const classes = () => {
    let classes;

    if (local.plaintext) {
      classes = {
        [`${bsPrefix}-plaintext`]: true
      };
    } else {
      classes = {
        [bsPrefix]: true,
        [`${bsPrefix}-${local.size}`]: local.size
      };
    }

    return classes;
  };

  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get type() {
      return local.type;
    },

    get size() {
      return local.htmlSize;
    },

    get readOnly() {
      return local.readOnly;
    },

    get id() {
      return local.id || formContext.controlId;
    },

    get ["class"]() {
      return classNames(classes(), local.isValid && `is-valid`, local.isInvalid && `is-invalid`, local.type === "color" && `${bsPrefix}-color`);
    }

  }));
};

var FormControl$1 = Object.assign(FormControl, {
  Feedback: Feedback$1
});

var FormFloating = createWithBsPrefix("form-floating");

const defaultProps$E = {
  as: "label",
  column: false,
  visuallyHidden: false
};

const FormLabel = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$E, p), ["as", "bsPrefix", "column", "visuallyHidden", "class", "htmlFor"]);
  const formContext = useContext(FormContext$1);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "form-label");
  let columnClass = "col-form-label";
  if (typeof local.column === "string") columnClass = `${columnClass} ${columnClass}-${local.column}`;

  const classes = () => classNames(local.class, bsPrefix, local.visuallyHidden && "visually-hidden", local.column && columnClass);

  return !!local.column ? createComponent(Col$1, mergeProps$1({
    as: "label",

    get ["class"]() {
      return classes();
    },

    get htmlFor() {
      return local.htmlFor || formContext.controlId;
    }

  }, props)) : createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },

    get ["class"]() {
      return classes();
    },

    get htmlFor() {
      return local.htmlFor || formContext.controlId;
    }

  }, props));
};

var FormLabel$1 = FormLabel;

const _tmpl$$h = /*#__PURE__*/template(`<input>`, 1);
const defaultProps$D = {
  as: "img"
};

const FormRange = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$D, p), ["bsPrefix", "class", "id"]);
  const formContext = useContext(FormContext$1);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "form-range");
  return (() => {
    const _el$ = _tmpl$$h.cloneNode(true);

    spread(_el$, mergeProps$1(props, {
      "type": "range",

      get ["class"]() {
        return classNames(local.class, bsPrefix);
      },

      get id() {
        return local.id || formContext.controlId;
      }

    }), false, false);

    return _el$;
  })();
};

var FormRange$1 = FormRange;

const _tmpl$$g = /*#__PURE__*/template(`<select></select>`, 2);
const defaultProps$C = {
  isValid: false,
  isInvalid: false
};

const FormSelect = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$C, p), ["bsPrefix", "size", "htmlSize", "class", "isValid", "isInvalid", "id"]);
  const formContext = useContext(FormContext$1);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "form-select");
  return (() => {
    const _el$ = _tmpl$$g.cloneNode(true);

    spread(_el$, mergeProps$1(props, {
      get size() {
        return local.htmlSize;
      },

      get ["class"]() {
        return classNames(local.class, bsPrefix, local.size && `${bsPrefix}-${local.size}`, local.isValid && `is-valid`, local.isInvalid && `is-invalid`);
      },

      get id() {
        return local.id || formContext.controlId;
      }

    }), false, false);

    return _el$;
  })();
};

var FormSelect$1 = FormSelect;

const defaultProps$B = {
  as: "small"
};

const FormText = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$B, p), ["as", "bsPrefix", "class", "muted"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "form-text");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, bsPrefix, local.muted && "text-muted");
    }

  }));
};

var FormText$1 = FormText;

const Switch = props => createComponent(FormCheck$1, mergeProps$1(props, {
  type: "switch"
}));

var Switch$1 = Object.assign(Switch, {
  Input: FormCheck$1.Input,
  Label: FormCheck$1.Label
});

const defaultProps$A = {
  as: "form"
};

const Form = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$A, p), ["as", "class", "validated"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, local.validated && "was-validated");
    }

  }));
};

var Form$1 = Object.assign(Form, {
  Group: FormGroup$1,
  Control: FormControl$1,
  Floating: FormFloating,
  Check: FormCheck$1,
  Switch: Switch$1,
  Label: FormLabel$1,
  Text: FormText$1,
  Range: FormRange$1,
  Select: FormSelect$1,
  FloatingLabel: FloatingLabel$1
});

const InputGroupText = createWithBsPrefix("input-group-text", {
  Component: "span"
});

const InputGroupCheckbox = props => createComponent(InputGroupText, {
  get children() {
    return createComponent(FormCheckInput$1, mergeProps$1({
      type: "checkbox"
    }, props));
  }

});

const InputGroupRadio = props => createComponent(InputGroupText, {
  get children() {
    return createComponent(FormCheckInput$1, mergeProps$1({
      type: "radio"
    }, props));
  }

});

const defaultProps$z = {
  as: "div"
};
/**
 *
 * @property {InputGroupText} Text
 * @property {InputGroupRadio} Radio
 * @property {InputGroupCheckbox} Checkbox
 */

const InputGroup = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$z, p), ["as", "bsPrefix", "size", "hasValidation", "class"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "input-group"); // Intentionally an empty object. Used in detecting if a dropdown
  // exists under an input group.

  const contextValue = {};
  return createComponent(InputGroupContext.Provider, {
    value: contextValue,

    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }

      }, props, {
        get ["class"]() {
          return classNames(local.class, bsPrefix, local.size && `${bsPrefix}-${local.size}`, local.hasValidation && "has-validation");
        }

      }));
    }

  });
};

var InputGroup$1 = Object.assign(InputGroup, {
  Text: InputGroupText,
  Radio: InputGroupRadio,
  Checkbox: InputGroupCheckbox
});

const defaultProps$y = {};

const ListGroupItem = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$y, p), ["as", "bsPrefix", "active", "disabled", "eventKey", "class", "variant", "action"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "list-group-item");
  const [navItemProps, meta] = useNavItem(mergeProps({
    get key() {
      return makeEventKey(local.eventKey, props.href);
    },

    get active() {
      return local.active;
    }

  }, props));
  const handleClick = createMemo(() => event => {
    if (local.disabled) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }

    navItemProps.onClick(event);
  });

  const disabledProps = () => local.disabled && props.tabIndex === undefined ? {
    tabIndex: -1,
    ["aria-disabled"]: true
  } : {};

  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as || (local.action ? props.href ? "a" : "button" : "div");
    }

  }, props, navItemProps, disabledProps, {
    get onClick() {
      return handleClick();
    },

    get ["class"]() {
      return classNames(local.class, bsPrefix, meta.isActive && "active", local.disabled && "disabled", local.variant && `${bsPrefix}-${local.variant}`, local.action && `${bsPrefix}-action`);
    }

  }));
};

var ListGroupItem$1 = ListGroupItem;

const defaultProps$x = {
  as: "div"
};

const ListGroup = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$x, p), ["as", "activeKey", "defaultActiveKey", "bsPrefix", "class", "variant", "horizontal", "numbered", "onSelect"]);
  const [activeKey, onSelect] = createControlledProp(() => local.activeKey, () => local.defaultActiveKey, local.onSelect);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "list-group");
  let horizontalVariant;

  if (local.horizontal) {
    horizontalVariant = local.horizontal === true ? "horizontal" : `horizontal-${local.horizontal}`;
  }

  return createComponent(Nav$2, mergeProps$1({
    get as() {
      return local.as;
    }

  }, props, {
    get activeKey() {
      return activeKey();
    },

    onSelect: onSelect,

    get ["class"]() {
      return classNames(local.class, bsPrefix, local.variant && `${bsPrefix}-${local.variant}`, horizontalVariant && `${bsPrefix}-${horizontalVariant}`, local.numbered && `${bsPrefix}-numbered`);
    }

  }));
};

var ListGroup$1 = Object.assign(ListGroup, {
  Item: ListGroupItem$1
});

var size;
function scrollbarSize(recalc) {
  if (!size && size !== 0 || recalc) {
    if (canUseDOM) {
      var scrollDiv = document.createElement('div');
      scrollDiv.style.position = 'absolute';
      scrollDiv.style.top = '-9999px';
      scrollDiv.style.width = '50px';
      scrollDiv.style.height = '50px';
      scrollDiv.style.overflow = 'scroll';
      document.body.appendChild(scrollDiv);
      size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
    }
  }

  return size;
}

var ModalBody = createWithBsPrefix("modal-body");

const ModalContext = createContext({
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  onHide() {}

});
var ModalContext$1 = ModalContext;

const _tmpl$$f = /*#__PURE__*/template(`<div><div></div></div>`, 4);
const defaultProps$w = {};

const ModalDialog = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$w, p), ["bsPrefix", "class", "contentClass", "centered", "size", "fullscreen", "children", "scrollable"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "modal");
  const dialogClass = `${bsPrefix}-dialog`;
  const fullScreenClass = typeof local.fullscreen === "string" ? `${bsPrefix}-fullscreen-${local.fullscreen}` : `${bsPrefix}-fullscreen`;
  return (() => {
    const _el$ = _tmpl$$f.cloneNode(true),
          _el$2 = _el$.firstChild;

    spread(_el$, mergeProps$1(props, {
      get ["class"]() {
        return classNames(dialogClass, local.class, local.size && `${bsPrefix}-${local.size}`, local.centered && `${dialogClass}-centered`, local.scrollable && `${dialogClass}-scrollable`, local.fullscreen && fullScreenClass);
      }

    }), false, true);

    insert(_el$2, () => local.children);

    effect(() => className(_el$2, classNames(`${bsPrefix}-content`, local.contentClass, local.contentClass)));

    return _el$;
  })();
};

var ModalDialog$1 = ModalDialog;

var ModalFooter = createWithBsPrefix("modal-footer");

const _tmpl$$e = /*#__PURE__*/template(`<div></div>`, 2);
const defaultProps$v = {
  closeLabel: "Close",
  closeButton: false
};

const AbstractModalHeader = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$v, p), ["closeLabel", "closeVariant", "closeButton", "onHide", "children"]);
  const context = useContext(ModalContext$1);

  const handleClick = () => {
    context?.onHide();
    local.onHide?.();
  };

  return (() => {
    const _el$ = _tmpl$$e.cloneNode(true);

    spread(_el$, props, false, true);

    insert(_el$, () => local.children, null);

    insert(_el$, (() => {
      const _c$ = memo(() => !!local.closeButton);

      return () => _c$() && createComponent(CloseButton$1, {
        get ["aria-label"]() {
          return local.closeLabel;
        },

        get variant() {
          return local.closeVariant;
        },

        onClick: handleClick
      });
    })(), null);

    return _el$;
  })();
};

var AbstractModalHeader$1 = AbstractModalHeader;

const defaultProps$u = {
  closeLabel: "Close",
  closeButton: false
};

const ModalHeader = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$u, p), ["bsPrefix", "class"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "modal-header");
  return createComponent(AbstractModalHeader$1, mergeProps$1(props, {
    get ["class"]() {
      return classNames(local.class, bsPrefix);
    }

  }));
};

var ModalHeader$1 = ModalHeader;

const DivStyledAsH4 = divWithClass("h4");
var ModalTitle = createWithBsPrefix("modal-title", {
  Component: DivStyledAsH4
});

const _tmpl$$d = /*#__PURE__*/template(`<div></div>`, 2),
      _tmpl$2$4 = /*#__PURE__*/template(`<div role="dialog"></div>`, 2);
const defaultProps$t = {
  show: false,
  backdrop: true,
  keyboard: true,
  autoFocus: true,
  enforceFocus: true,
  restoreFocus: true,
  animation: true,
  dialogAs: ModalDialog$1
};
/* eslint-disable no-use-before-define, react/no-multi-comp */

function DialogTransition$1(props) {
  return createComponent(Fade$1, mergeProps$1(props, {
    timeout: undefined
  }));
}

function BackdropTransition$1(props) {
  return createComponent(Fade$1, mergeProps$1(props, {
    timeout: undefined
  }));
}
/* eslint-enable no-use-before-define */


const Modal = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$t, p), ["bsPrefix", "class", "style", "dialogClass", "contentClass", "children", "dialogAs", "aria-labelledby",
  /* BaseModal props */
  "show", "animation", "backdrop", "keyboard", "onEscapeKeyDown", "onShow", "onHide", "container", "autoFocus", "enforceFocus", "restoreFocus", "restoreFocusOptions", "onEntered", "onExit", "onExiting", "onEnter", "onEntering", "onExited", "backdropClass", "manager"]);
  const [modalStyle, setStyle] = createSignal({});
  const [animateStaticModal, setAnimateStaticModal] = createSignal(false);
  let waitingForMouseUpRef = false;
  let ignoreBackdropClickRef = false;
  let removeStaticModalAnimationRef = null;
  let modal;
  const isRTL = useIsRTL();

  const mergedRef = ref => {
    modal = ref;
    props.ref?.(ref);
  };

  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "modal");
  const modalContext = {
    get onHide() {
      return local.onHide;
    }

  };

  function getModalManager() {
    if (local.manager) return local.manager;
    return getSharedManager({
      isRTL: isRTL()
    });
  }

  function updateDialogStyle(node) {
    if (!canUseDOM) return;
    const containerIsOverflowing = getModalManager().getScrollbarWidth() > 0;
    const modalIsOverflowing = node.scrollHeight > ownerDocument(node).documentElement.clientHeight;
    setStyle({
      paddingRight: containerIsOverflowing && !modalIsOverflowing ? scrollbarSize() : undefined,
      paddingLeft: !containerIsOverflowing && modalIsOverflowing ? scrollbarSize() : undefined
    });
  }

  const handleWindowResize = () => {
    if (modal) {
      updateDialogStyle(modal.dialog);
    }
  };

  onCleanup(() => {
    removeEventListener(window, "resize", handleWindowResize);
    removeStaticModalAnimationRef?.();
  }); // We prevent the modal from closing during a drag by detecting where the
  // the click originates from. If it starts in the modal and then ends outside
  // don't close.

  const handleDialogMouseDown = () => {
    waitingForMouseUpRef = true;
  };

  const handleMouseUp = e => {
    if (waitingForMouseUpRef && modal && e.target === modal.dialog) {
      ignoreBackdropClickRef = true;
    }

    waitingForMouseUpRef = false;
  };

  const handleStaticModalAnimation = () => {
    setAnimateStaticModal(true);
    removeStaticModalAnimationRef = transitionEnd(modal.dialog, () => {
      setAnimateStaticModal(false);
    });
  };

  const handleStaticBackdropClick = e => {
    if (e.target !== e.currentTarget) {
      return;
    }

    handleStaticModalAnimation();
  };

  const handleClick = e => {
    if (local.backdrop === "static") {
      handleStaticBackdropClick(e);
      return;
    }

    if (ignoreBackdropClickRef || e.target !== e.currentTarget) {
      ignoreBackdropClickRef = false;
      return;
    }

    local.onHide?.();
  };

  const handleEscapeKeyDown = e => {
    if (!local.keyboard && local.backdrop === "static") {
      // Call preventDefault to stop modal from closing in restart ui,
      // then play our animation.
      e.preventDefault();
      handleStaticModalAnimation();
    } else if (local.keyboard && local.onEscapeKeyDown) {
      local.onEscapeKeyDown(e);
    }
  };

  const handleEnter = (node, ...args) => {
    if (node) {
      // @ts-ignore
      node.style.display = "block";
      updateDialogStyle(node);
    }

    local.onEnter?.(node, ...args);
  };

  const handleExit = (...args) => {
    removeStaticModalAnimationRef?.();
    local.onExit?.(...args);
  };

  const handleEntering = (...args) => {
    local.onEntering?.(...args);

    if (!isServer) {
      // FIXME: This should work even when animation is disabled.
      addEventListener(window, "resize", handleWindowResize);
    }
  };

  const handleExited = node => {
    if (node) node.style.display = ""; // RHL removes it sometimes

    local.onExited?.(node);

    if (!isServer) {
      // FIXME: This should work even when animation is disabled.
      removeEventListener(window, "resize", handleWindowResize);
    }
  };

  const renderBackdrop = backdropProps => (() => {
    const _el$ = _tmpl$$d.cloneNode(true);

    spread(_el$, mergeProps$1(backdropProps, {
      get ["class"]() {
        return classNames(`${bsPrefix}-backdrop`, local.backdropClass, !local.animation && "show");
      }

    }), false, false);

    return _el$;
  })();

  const baseModalStyle = () => {
    let s = { ...local.style,
      ...modalStyle()
    }; // Sets `display` always block when `animation` is false

    if (!local.animation) {
      s.display = "block";
    }

    return s;
  };

  const renderDialog = dialogProps => (() => {
    const _el$2 = _tmpl$2$4.cloneNode(true);

    spread(_el$2, mergeProps$1(dialogProps, {
      get style() {
        return baseModalStyle();
      },

      get ["class"]() {
        return classNames(local.class, bsPrefix, animateStaticModal() && `${bsPrefix}-static`);
      },

      get onClick() {
        return local.backdrop ? handleClick : undefined;
      },

      "onMouseUp": handleMouseUp,

      get ["aria-labelledby"]() {
        return local["aria-labelledby"];
      }

    }), false, true);

    insert(_el$2, createComponent(Dynamic, mergeProps$1({
      get component() {
        return local.dialogAs;
      }

    }, props, {
      onMouseDown: handleDialogMouseDown,

      get ["class"]() {
        return local.dialogClass;
      },

      get contentClass() {
        return local.contentClass;
      },

      get children() {
        return local.children;
      }

    })));

    return _el$2;
  })();

  return createComponent(ModalContext$1.Provider, {
    value: modalContext,

    get children() {
      return createComponent(Modal$2, {
        get show() {
          return local.show;
        },

        ref: mergedRef,

        get backdrop() {
          return local.backdrop;
        },

        get container() {
          return local.container;
        },

        keyboard: true,

        get autoFocus() {
          return local.autoFocus;
        },

        get enforceFocus() {
          return local.enforceFocus;
        },

        get restoreFocus() {
          return local.restoreFocus;
        },

        get restoreFocusOptions() {
          return local.restoreFocusOptions;
        },

        onEscapeKeyDown: handleEscapeKeyDown,

        get onShow() {
          return local.onShow;
        },

        get onHide() {
          return local.onHide;
        },

        onEnter: handleEnter,
        onEntering: handleEntering,

        get onEntered() {
          return local.onEntered;
        },

        onExit: handleExit,

        get onExiting() {
          return local.onExiting;
        },

        onExited: handleExited,

        get manager() {
          return getModalManager();
        },

        get transition() {
          return local.animation ? DialogTransition$1 : undefined;
        },

        get backdropTransition() {
          return local.animation ? BackdropTransition$1 : undefined;
        },

        renderBackdrop: renderBackdrop,
        renderDialog: renderDialog
      });
    }

  });
};

var Modal$1 = Object.assign(Modal, {
  Body: ModalBody,
  Header: ModalHeader$1,
  Title: ModalTitle,
  Footer: ModalFooter,
  Dialog: ModalDialog$1,
  TRANSITION_DURATION: 300,
  BACKDROP_TRANSITION_DURATION: 150
});

var NavItem = createWithBsPrefix("nav-item");

const defaultProps$s = {
  as: Anchor,
  disabled: false
};

const NavLink = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$s, p), ["as", "bsPrefix", "class", "active", "eventKey"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "nav-link");
  const [navItemProps, meta] = useNavItem(mergeProps({
    get key() {
      return makeEventKey(local.eventKey, props.href);
    },

    get active() {
      return local.active;
    }

  }, props));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, navItemProps, {
    get ["class"]() {
      return classNames(local.class, bsPrefix, props.disabled && "disabled", meta.isActive && "active");
    }

  }));
};

var NavLink$1 = NavLink;

const defaultProps$r = {
  as: "div",
  justify: false,
  fill: false
};

const Nav = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$r, p), ["as", "activeKey", "defaultActiveKey", "bsPrefix", "variant", "fill", "justify", "navbar", "navbarScroll", "class", "onSelect"]);
  const [activeKey, onSelect] = createControlledProp(() => local.activeKey, () => local.defaultActiveKey, local.onSelect);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "nav");
  let navbarBsPrefix;
  let cardHeaderBsPrefix;
  let isNavbar = false;
  const navbarContext = useContext(NavbarContext);
  const cardHeaderContext = useContext(CardHeaderContext);

  if (navbarContext) {
    navbarBsPrefix = navbarContext.bsPrefix;
    isNavbar = local.navbar == null ? true : local.navbar;
  } else if (cardHeaderContext) {
    ({
      cardHeaderBsPrefix
    } = cardHeaderContext);
  }

  return createComponent(Nav$2, mergeProps$1({
    get as() {
      return local.as;
    },

    get activeKey() {
      return activeKey();
    },

    onSelect: onSelect,

    get ["class"]() {
      return classNames(local.class, {
        [bsPrefix]: !isNavbar,
        [`${navbarBsPrefix}-nav`]: isNavbar,
        [`${navbarBsPrefix}-nav-scroll`]: isNavbar && local.navbarScroll,
        [`${cardHeaderBsPrefix}-${local.variant}`]: !!cardHeaderBsPrefix,
        [`${bsPrefix}-${local.variant}`]: !!local.variant,
        [`${bsPrefix}-fill`]: local.fill,
        [`${bsPrefix}-justified`]: local.justify
      });
    }

  }, props));
};

var Nav$1 = Object.assign(Nav, {
  Item: NavItem,
  Link: NavLink$1
});

const defaultProps$q = {};

const NavbarBrand = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$q, p), ["as", "bsPrefix", "class"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "navbar-brand");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as || (props.href ? "a" : "span");
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, bsPrefix);
    }

  }));
};

var NavbarBrand$1 = NavbarBrand;

const _tmpl$$c = /*#__PURE__*/template(`<div></div>`, 2);
const defaultProps$p = {};

const NavbarCollapse = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$p, p), ["bsPrefix", "class", "children", "ref"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "navbar-collapse");
  const context = useContext(NavbarContext);
  return createComponent(Collapse$1, mergeProps$1({
    get ["in"]() {
      return !!context?.expanded;
    }

  }, props, {
    get children() {
      const _el$ = _tmpl$$c.cloneNode(true);

      const _ref$ = local.ref;
      typeof _ref$ === "function" ? use(_ref$, _el$) : local.ref = _el$;

      insert(_el$, () => local.children);

      effect(() => className(_el$, classNames(bsPrefix, local.class)));

      return _el$;
    }

  }));
};

var NavbarCollapse$1 = NavbarCollapse;

const _tmpl$$b = /*#__PURE__*/template(`<span></span>`, 2);
const defaultProps$o = {
  as: "button",
  label: "Toggle navigation"
};

const NavbarToggle = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$o, p), ["as", "bsPrefix", "class", "children", "label", "onClick"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "navbar-toggler");
  const context = useContext(NavbarContext);

  const handleClick = e => {
    callEventHandler(local.onClick, e);
    context?.onToggle?.();
  };

  if (local.as === "button") {
    props.type = "button";
  }

  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get type() {
      return local.as === "button" ? "button" : undefined;
    },

    onClick: handleClick,

    get ["aria-label"]() {
      return local.label;
    },

    get ["class"]() {
      return classNames(local.class, bsPrefix, !context?.expanded && "collapsed");
    },

    get children() {
      return local.children || (() => {
        const _el$ = _tmpl$$b.cloneNode(true);

        className(_el$, `${bsPrefix}-icon`);

        return _el$;
      })();
    }

  }));
};

var NavbarToggle$1 = NavbarToggle;

var OffcanvasBody = createWithBsPrefix("offcanvas-body");

const defaultProps$n = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false
};
const transitionStyles = {
  [ENTERING]: "show",
  [ENTERED]: "show"
};

const OffcanvasToggling = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$n, p), ["bsPrefix", "class", "children"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "offcanvas");
  const resolvedChildren = children(() => local.children);
  let prevClasses;
  return createComponent(TransitionWrapper$1, mergeProps$1({
    addEndListener: transitionEndListener
  }, props, {
    children: (status, innerProps) => {
      const el = resolvedChildren();
      innerProps.ref(el);
      const newClasses = classNames(local.class, (status === ENTERING || status === EXITING) && `${bsPrefix}-toggling`, // @ts-ignore
      transitionStyles[status]);
      resolveClasses(el, prevClasses, newClasses);
      prevClasses = newClasses;
      return el;
    }
  }));
};

var OffcanvasToggling$1 = OffcanvasToggling;

const defaultProps$m = {
  closeLabel: "Close",
  closeButton: false
};

const OffcanvasHeader = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$m, p), ["bsPrefix", "class"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "offcanvas-header");
  return createComponent(AbstractModalHeader$1, mergeProps$1(props, {
    get ["class"]() {
      return classNames(local.class, bsPrefix);
    }

  }));
};

var OffcanvasHeader$1 = OffcanvasHeader;

const DivStyledAsH5 = divWithClass("h5");
var OffcanvasTitle = createWithBsPrefix("offcanvas-title", {
  Component: DivStyledAsH5
});

const _tmpl$$a = /*#__PURE__*/template(`<div></div>`, 2),
      _tmpl$2$3 = /*#__PURE__*/template(`<div role="dialog"></div>`, 2);
const defaultProps$l = {
  show: false,
  backdrop: true,
  keyboard: true,
  scroll: false,
  autoFocus: true,
  enforceFocus: true,
  restoreFocus: true,
  placement: "start"
};

function DialogTransition(props) {
  return createComponent(OffcanvasToggling$1, props);
}

function BackdropTransition(props) {
  return createComponent(Fade$1, props);
}

const Offcanvas = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$l, p), ["bsPrefix", "class", "children", "aria-labelledby", "placement",
  /*BaseModal props */
  "show", "backdrop", "keyboard", "scroll", "onEscapeKeyDown", "onShow", "onHide", "container", "autoFocus", "enforceFocus", "restoreFocus", "restoreFocusOptions", "onEntered", "onExit", "onExiting", "onEnter", "onEntering", "onExited", "backdropClass", "manager", "ref"]);
  let modalManager;
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "offcanvas");
  const navbarContext = useContext(NavbarContext);

  const handleHide = () => {
    navbarContext?.onToggle?.();
    local.onHide?.();
  };

  const modalContext = {
    get onHide() {
      return handleHide;
    }

  };

  function getModalManager() {
    if (local.manager) return local.manager;

    if (local.scroll) {
      // Have to use a different modal manager since the shared
      // one handles overflow.
      if (!modalManager) modalManager = new BootstrapModalManager({
        handleContainerOverflow: false
      });
      return modalManager;
    }

    return getSharedManager();
  }

  const handleEnter = (node, ...args) => {
    if (node) node.style.visibility = "visible";
    local.onEnter?.(node, ...args);
  };

  const handleExited = (node, ...args) => {
    if (node) node.style.visibility = "";
    local.onExited?.(...args);
  };

  const renderBackdrop = backdropProps => (() => {
    const _el$ = _tmpl$$a.cloneNode(true);

    spread(_el$, mergeProps$1(backdropProps, {
      get ["class"]() {
        return classNames(`${bsPrefix}-backdrop`, local.backdropClass);
      }

    }), false, true);

    insert(_el$, () => props.children);

    return _el$;
  })();

  const renderDialog = dialogProps => (() => {
    const _el$2 = _tmpl$2$3.cloneNode(true);

    spread(_el$2, mergeProps$1(dialogProps, props, {
      get ["class"]() {
        return classNames(local.class, bsPrefix, `${bsPrefix}-${local.placement}`);
      },

      get ["aria-labelledby"]() {
        return local["aria-labelledby"];
      }

    }), false, true);

    insert(_el$2, () => local.children);

    return _el$2;
  })();

  return createComponent(ModalContext$1.Provider, {
    value: modalContext,

    get children() {
      return createComponent(Modal$2, {
        get show() {
          return local.show;
        },

        ref(r$) {
          const _ref$ = local.ref;
          typeof _ref$ === "function" ? _ref$(r$) : local.ref = r$;
        },

        get backdrop() {
          return local.backdrop;
        },

        get container() {
          return local.container;
        },

        get keyboard() {
          return local.keyboard;
        },

        get autoFocus() {
          return local.autoFocus;
        },

        get enforceFocus() {
          return local.enforceFocus && !scroll;
        },

        get restoreFocus() {
          return local.restoreFocus;
        },

        get restoreFocusOptions() {
          return local.restoreFocusOptions;
        },

        get onEscapeKeyDown() {
          return local.onEscapeKeyDown;
        },

        get onShow() {
          return local.onShow;
        },

        onHide: handleHide,
        onEnter: handleEnter,

        get onEntering() {
          return local.onEntering;
        },

        get onEntered() {
          return local.onEntered;
        },

        get onExit() {
          return local.onExit;
        },

        get onExiting() {
          return local.onExiting;
        },

        onExited: handleExited,

        get manager() {
          return getModalManager();
        },

        transition: DialogTransition,
        backdropTransition: BackdropTransition,
        renderBackdrop: renderBackdrop,
        renderDialog: renderDialog
      });
    }

  });
};

var Offcanvas$1 = Object.assign(Offcanvas, {
  Body: OffcanvasBody,
  Header: OffcanvasHeader$1,
  Title: OffcanvasTitle
});

const NavbarOffcanvas = props => {
  const context = useContext(NavbarContext);
  return createComponent(Offcanvas$1, mergeProps$1({
    get show() {
      return !!context?.expanded;
    }

  }, props));
};

var NavbarOffcanvas$1 = NavbarOffcanvas;

const NavbarText = createWithBsPrefix("navbar-text", {
  Component: "span"
});
const defaultProps$k = {
  as: "nav",
  expand: true,
  variant: "light",
  collapseOnSelect: false
};

const Navbar = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$k, p), ["as", "bsPrefix", "expand", "variant", "bg", "fixed", "sticky", "class", "expanded", "defaultExpanded", "onToggle", "onSelect", "collapseOnSelect"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "navbar");
  const [expanded, onToggle] = createControlledProp(() => local.expanded, () => local.defaultExpanded, local.onToggle);

  const handleCollapse = (...args) => {
    local.onSelect?.(...args);

    if (local.collapseOnSelect && expanded()) {
      onToggle?.(false);
    }
  };

  const expandClass = () => {
    let expandClass = `${bsPrefix}-expand`;
    if (typeof local.expand === "string") expandClass = `${expandClass}-${local.expand}`;
    return expandClass;
  };

  const navbarContext = {
    get onToggle() {
      return () => onToggle?.(!expanded());
    },

    bsPrefix,

    get expanded() {
      return !!expanded();
    }

  };
  return createComponent(NavbarContext.Provider, {
    value: navbarContext,

    get children() {
      return createComponent(SelectableContext.Provider, {
        value: handleCollapse,

        get children() {
          return createComponent(Dynamic, mergeProps$1({
            get component() {
              return local.as;
            }

          }, props, {
            get role() {
              return (// will result in some false positives but that seems better
                // than false negatives. strict `undefined` check allows explicit
                // "nulling" of the role if the user really doesn't want one
                props.role === undefined && local.as !== "nav" ? "Navigation" : props.role
              );
            },

            get ["class"]() {
              return classNames(local.class, bsPrefix, local.expand && expandClass(), local.variant && `${bsPrefix}-${local.variant}`, local.bg && `bg-${local.bg}`, local.sticky && `sticky-${local.sticky}`, local.fixed && `fixed-${local.fixed}`);
            }

          }));
        }

      });
    }

  });
};

var Navbar$1 = Object.assign(Navbar, {
  Brand: NavbarBrand$1,
  Collapse: NavbarCollapse$1,
  Offcanvas: NavbarOffcanvas$1,
  Text: NavbarText,
  Toggle: NavbarToggle$1
});

const NavContext = createContext(null);
var NavContext$1 = NavContext;

const defaultProps$j = {};

const NavDropdown = p => {
  /* NavItem has no additional logic, it's purely presentational. Can set nav item class here to support "as" */
  const [local, props] = splitProps(mergeProps(defaultProps$j, p), ["id", "title", "children", "bsPrefix", "class", "rootCloseEvent", "menuRole", "disabled", "active", "renderMenuOnMount", "menuVariant"]);
  const navItemPrefix = useBootstrapPrefix(undefined, "nav-item");
  return createComponent(Dropdown$1, mergeProps$1(props, {
    get ["class"]() {
      return classNames(local.class, navItemPrefix);
    },

    get children() {
      return [createComponent(Dropdown$1.Toggle, {
        get id() {
          return local.id;
        },

        eventKey: null,

        get active() {
          return local.active;
        },

        get disabled() {
          return local.disabled;
        },

        get childBsPrefix() {
          return local.bsPrefix;
        },

        as: NavLink$1,

        get children() {
          return local.title;
        }

      }), createComponent(Dropdown$1.Menu, {
        get role() {
          return local.menuRole;
        },

        get renderOnMount() {
          return local.renderMenuOnMount;
        },

        get rootCloseEvent() {
          return local.rootCloseEvent;
        },

        get variant() {
          return local.menuVariant;
        },

        get children() {
          return local.children;
        }

      })];
    }

  }));
};

var NavDropdown$1 = Object.assign(NavDropdown, {
  Item: Dropdown$1.Item,
  ItemText: Dropdown$1.ItemText,
  Divider: Dropdown$1.Divider,
  Header: Dropdown$1.Header
});

const OverlayContext = createContext();
var OverlayContext$1 = OverlayContext;

const defaultProps$i = {
  transition: Fade$1,
  rootClose: false,
  show: false,
  placement: "top",
  popperConfig: {}
};

const Overlay = p => {
  const [local, outerProps] = splitProps(mergeProps(defaultProps$i, p), ["children"
  /*overlay*/
  , "transition", "popperConfig", "ref"]);
  const actualTransition = local.transition === true ? Fade$1 : local.transition || undefined;
  const [wrapperProps, setWrapperProps] = createSignal();
  const [arrowProps, setArrowProps] = createSignal();
  const [metadata, setMetadata] = createSignal();
  const overlayContext = {
    get wrapperProps() {
      return wrapperProps()?.();
    },

    get arrowProps() {
      return arrowProps()?.();
    },

    get metadata() {
      return metadata()?.();
    }

  };
  return createComponent(OverlayContext$1.Provider, {
    value: overlayContext,

    get children() {
      return createComponent(Overlay$2, mergeProps$1(outerProps, {
        get popperConfig() {
          return local.popperConfig;
        },

        transition: actualTransition,
        children: (wrapperProps, arrowProps, metadata) => {
          batch(() => {
            setWrapperProps(() => wrapperProps);
            setArrowProps(() => arrowProps);
            setMetadata(() => metadata);
          });
          return local.children;
        }
      }));
    }

  });
};

var Overlay$1 = Overlay;

/* eslint-disable no-bitwise, no-cond-assign */

/**
 * Checks if an element contains another given element.
 * 
 * @param context the context element
 * @param node the element to check
 */
function contains(context, node) {
  // HTML DOM and SVG DOM may have different support levels,
  // so we need to check on context instead of a document root element.
  if (context.contains) return context.contains(node);
  if (context.compareDocumentPosition) return context === node || !!(context.compareDocumentPosition(node) & 16);
}

function normalizeDelay(delay) {
  return delay && typeof delay === "object" ? delay : {
    show: delay,
    hide: delay
  };
} // Simple implementation of mouseEnter and mouseLeave.
// React's built version is broken: https://github.com/facebook/react/issues/4251
// for cases when the trigger is disabled and mouseOut/Over can cause flicker
// moving from one child element to another.


function handleMouseOverOut( // eslint-disable-next-line @typescript-eslint/no-shadow
handler, args, relatedNative) {
  const [e] = args;
  const target = e.currentTarget;
  const related = e.relatedTarget;

  if ((!related || related !== target) && !contains(target, related)) {
    handler(...args);
  }
}

const defaultProps$h = {
  defaultShow: false,
  trigger: ["hover", "focus"],
  popperConfig: {}
};

function OverlayTrigger(p) {
  const [local, props] = splitProps(mergeProps(defaultProps$h, {
    flip: p.placement && p.placement.indexOf("auto") !== -1
  }, p), ["trigger", "overlay", "children", "popperConfig", "show", "defaultShow", "onToggle", "delay", "placement", "flip"]);
  let [triggerNodeRef, setTriggerNodeRef] = createSignal();
  let timeout;
  let hoverStateRef = "";
  const [show, setShow] = createControlledProp(() => local.show, () => local.defaultShow, local.onToggle);
  const delay = normalizeDelay(local.delay);

  const handleShow = () => {
    window.clearTimeout(timeout);
    hoverStateRef = "show";

    if (!delay.show) {
      setShow(true);
      return;
    }

    timeout = window.setTimeout(() => {
      if (hoverStateRef === "show") setShow(true);
    }, delay.show);
  };

  const handleHide = () => {
    window.clearTimeout(timeout);
    hoverStateRef = "hide";

    if (!delay.hide) {
      setShow(false);
      return;
    }

    timeout = window.setTimeout(() => {
      if (hoverStateRef === "hide") setShow(false);
    }, delay.hide);
  };

  const handleFocus = (...args) => {
    handleShow();
  };

  const handleBlur = (...args) => {
    handleHide();
  };

  const handleClick = (...args) => {
    setShow(!show());
  };

  const handleMouseOver = (...args) => {
    handleMouseOverOut(handleShow, args);
  };

  const handleMouseOut = (...args) => {
    handleMouseOverOut(handleHide, args);
  };

  const addListeners = el => {
    const triggers = local.trigger == null ? [] : [].concat(local.trigger);

    if (triggers.indexOf("click") !== -1) {
      el.addEventListener("click", handleClick);
    }

    if (triggers.indexOf("focus") !== -1) {
      el.addEventListener("focus", handleFocus);
      el.addEventListener("blur", handleBlur);
    }

    if (triggers.indexOf("hover") !== -1) {
      el.addEventListener("mouseover", handleMouseOver);
      el.addEventListener("mouseout", handleMouseOut);
    } // no need to cleanup as element will be removed anyway

  };

  const resolvedChildren = children(() => local.children);

  const Target = () => {
    let el = resolvedChildren(); // children() returns a function if the function takes arguments

    while (typeof el === "function") el = el();

    setTriggerNodeRef(el);

    if (!isServer) {
      addListeners(el);
    }

    return el;
  };

  return [createComponent(Target, {}), createComponent(Overlay$1, mergeProps$1(props, {
    get show() {
      return show();
    },

    onHide: handleHide,

    get flip() {
      return local.flip;
    },

    get placement() {
      return local.placement;
    },

    get popperConfig() {
      return local.popperConfig;
    },

    target: triggerNodeRef,

    get children() {
      return local.overlay;
    }

  }))];
}

const _tmpl$$9 = /*#__PURE__*/template(`<li></li>`, 2),
      _tmpl$2$2 = /*#__PURE__*/template(`<span class="visually-hidden"></span>`, 2),
      _tmpl$3 = /*#__PURE__*/template(`<span aria-hidden="true"></span>`, 2);
const defaultProps$g = {
  active: false,
  disabled: false,
  activeLabel: "(current)"
};

const PageItem = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$g, p), ["active", "disabled", "class", "style", "activeLabel", "children", "ref"]);
  return (() => {
    const _el$ = _tmpl$$9.cloneNode(true);

    const _ref$ = local.ref;
    typeof _ref$ === "function" ? use(_ref$, _el$) : local.ref = _el$;

    insert(_el$, createComponent(Dynamic, mergeProps$1({
      get component() {
        return local.active || local.disabled ? "span" : Anchor;
      },

      "class": "page-link",

      get disabled() {
        return local.disabled;
      }

    }, props, {
      get children() {
        return [memo(() => local.children), memo(() => memo(() => !!(local.active && local.activeLabel))() && (() => {
          const _el$2 = _tmpl$2$2.cloneNode(true);

          insert(_el$2, () => local.activeLabel);

          return _el$2;
        })())];
      }

    })));

    effect(_p$ => {
      const _v$ = local.style,
            _v$2 = classNames(local.class, "page-item", {
        active: local.active,
        disabled: local.disabled
      });

      _p$._v$ = style$1(_el$, _v$, _p$._v$);
      _v$2 !== _p$._v$2 && className(_el$, _p$._v$2 = _v$2);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined
    });

    return _el$;
  })();
};

var PageItem$1 = PageItem;

function createButton(name, defaultValue, label = name) {
  function Button({
    children,
    ...props
  }) {
    return createComponent(PageItem, mergeProps$1(props, {
      get children() {
        return [(() => {
          const _el$3 = _tmpl$3.cloneNode(true);

          insert(_el$3, children || defaultValue);

          return _el$3;
        })(), (() => {
          const _el$4 = _tmpl$2$2.cloneNode(true);

          insert(_el$4, label);

          return _el$4;
        })()];
      }

    }));
  }

  Button.displayName = name;
  return Button;
}

const First = createButton("First", "«");
const Prev = createButton("Prev", "‹", "Previous");
const Ellipsis = createButton("Ellipsis", "…", "More");
const Next = createButton("Next", "›");
const Last = createButton("Last", "»");

const _tmpl$$8 = /*#__PURE__*/template(`<ul></ul>`, 2);
const defaultProps$f = {};
/**
 * @property {PageItem} Item
 * @property {PageItem} First
 * @property {PageItem} Prev
 * @property {PageItem} Ellipsis
 * @property {PageItem} Next
 * @property {PageItem} Last
 */

const Pagination = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$f, p), ["bsPrefix", "class", "size"]);
  const decoratedBsPrefix = useBootstrapPrefix(local.bsPrefix, "pagination");
  return (() => {
    const _el$ = _tmpl$$8.cloneNode(true);

    spread(_el$, mergeProps$1(props, {
      get ["class"]() {
        return classNames(local.class, decoratedBsPrefix, local.size && `${decoratedBsPrefix}-${local.size}`);
      }

    }), false, false);

    return _el$;
  })();
};

var Pagination$1 = Object.assign(Pagination, {
  First,
  Prev,
  Ellipsis,
  Item: PageItem$1,
  Next,
  Last
});

function usePlaceholder({
  animation,
  bg,
  bsPrefix,
  size,
  ...props
}) {
  bsPrefix = useBootstrapPrefix(bsPrefix, "placeholder");
  const [{
    class: class_,
    ...colProps
  }] = useCol(props);
  return { ...colProps,
    class: classNames(class_, animation ? `${bsPrefix}-${animation}` : bsPrefix, size && `${bsPrefix}-${size}`, bg && `bg-${bg}`)
  };
}

const PlaceholderButton = props => {
  return createComponent(Button$1, mergeProps$1(() => usePlaceholder(props), {
    disabled: true,
    tabIndex: -1,

    get children() {
      return props.children;
    }

  }));
};

var PlaceholderButton$1 = PlaceholderButton;

const defaultProps$e = {
  as: "span"
};

const Placeholder = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$e, p), ["as", "children"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, () => usePlaceholder(props), {
    get children() {
      return local.children;
    }

  }));
};

var Placeholder$1 = Object.assign(Placeholder, {
  Button: PlaceholderButton$1
});

var PopoverHeader = createWithBsPrefix("popover-header");

var PopoverBody = createWithBsPrefix("popover-body");

const _tmpl$$7 = /*#__PURE__*/template(`<div role="tooltip"><div class="popover-arrow"></div></div>`, 4);
const defaultProps$d = {
  arrowProps: {},
  placement: "right"
};

const Popover = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$d, p), ["bsPrefix", "placement", "class", "style", "children", "body", "arrowProps", "popper", "show"]);
  const decoratedBsPrefix = useBootstrapPrefix(local.bsPrefix, "popover");
  const context = useContext(OverlayContext$1);

  const primaryPlacement = () => (context?.metadata?.placement || local.placement)?.split("-")?.[0];

  return (() => {
    const _el$ = _tmpl$$7.cloneNode(true),
          _el$2 = _el$.firstChild;

    spread(_el$, mergeProps$1({
      get ["x-placement"]() {
        return primaryPlacement();
      },

      get ["class"]() {
        return classNames(local.class, decoratedBsPrefix, primaryPlacement() && `bs-popover-auto`);
      }

    }, props, () => context?.wrapperProps, {
      get style() {
        return Object.assign({}, local.style, context?.wrapperProps?.style);
      }

    }), false, true);

    spread(_el$2, mergeProps$1(() => local.arrowProps, () => context?.arrowProps), false, false);

    insert(_el$, (() => {
      const _c$ = memo(() => !!local.body);

      return () => _c$() ? createComponent(PopoverBody, {
        get children() {
          return local.children;
        }

      }) : local.children;
    })(), null);

    return _el$;
  })();
};

var Popover$1 = Object.assign(Popover, {
  Header: PopoverHeader,
  Body: PopoverBody
});

const _tmpl$$6 = /*#__PURE__*/template(`<div></div>`, 2),
      _tmpl$2$1 = /*#__PURE__*/template(`<span class="visually-hidden"></span>`, 2);
const ProgressContext = createContext();
const ROUND_PRECISION = 1000;
const defaultProps$c = {
  min: 0,
  max: 100,
  animated: false,
  visuallyHidden: false,
  striped: false
};

function getPercentage(now, min, max) {
  const percentage = (now - min) / (max - min) * 100;
  return Math.round(percentage * ROUND_PRECISION) / ROUND_PRECISION;
}

function renderProgressBar(p) {
  const [local, props] = splitProps(p, ["min", "now", "max", "label", "visuallyHidden", "striped", "animated", "class", "style", "variant", "bsPrefix"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "progress");
  return (() => {
    const _el$ = _tmpl$$6.cloneNode(true);

    spread(_el$, mergeProps$1(props, {
      "role": "progressbar",

      get ["class"]() {
        return classNames(local.class, `${bsPrefix}-bar`, {
          [`bg-${local.variant}`]: local.variant,
          [`${bsPrefix}-bar-animated`]: local.animated,
          [`${bsPrefix}-bar-striped`]: local.animated || local.striped
        });
      },

      get style() {
        return {
          width: `${getPercentage(local.now, local.min, local.max)}%`,
          ...local.style
        };
      },

      get ["aria-valuenow"]() {
        return local.now;
      },

      get ["aria-valuemin"]() {
        return local.min;
      },

      get ["aria-valuemax"]() {
        return local.max;
      }

    }), false, true);

    insert(_el$, (() => {
      const _c$ = memo(() => !!local.visuallyHidden);

      return () => _c$() ? (() => {
        const _el$2 = _tmpl$2$1.cloneNode(true);

        insert(_el$2, () => local.label);

        return _el$2;
      })() : local.label;
    })());

    return _el$;
  })();
}

const ProgressBar = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$c, p), ["children", "class", "bsPrefix"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "progress");
  const context = useContext(ProgressContext);
  let barProps = props;
  let wrapperProps = {};

  if (!context?.isStacked) {
    const [b, w] = splitProps(props, ["min", "now", "max", "label", "visuallyHidden", "striped", "animated", "variant"]);
    barProps = b;
    wrapperProps = w;
  }

  return context?.isStacked ? renderProgressBar(barProps) : createComponent(ProgressContext.Provider, {
    value: {
      isStacked: true
    },

    get children() {
      const _el$3 = _tmpl$$6.cloneNode(true);

      spread(_el$3, mergeProps$1(wrapperProps, {
        get ["class"]() {
          return classNames(local.class, bsPrefix);
        }

      }), false, true);

      insert(_el$3, () => local.children ?? renderProgressBar(barProps));

      return _el$3;
    }

  });
};

var ProgressBar$1 = ProgressBar;

const defaultProps$b = {
  as: "div"
};

const Row = p => {
  const breakpoints = useBootstrapBreakpoints();
  const [local, props] = splitProps(mergeProps(defaultProps$b, p), ["as", "bsPrefix", "class", ...breakpoints()]);
  const decoratedBsPrefix = useBootstrapPrefix(local.bsPrefix, "row");
  const sizePrefix = `${decoratedBsPrefix}-cols`;
  const classes = [];
  breakpoints().forEach(brkPoint => {
    const propValue = local[brkPoint];
    let cols;

    if (propValue != null && typeof propValue === "object") {
      ({
        cols
      } = propValue);
    } else {
      cols = propValue;
    }

    const infix = brkPoint !== "xs" ? `-${brkPoint}` : "";
    if (cols != null) classes.push(`${sizePrefix}${infix}-${cols}`);
  });
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, decoratedBsPrefix, ...classes);
    }

  }));
};

var Row$1 = Row;

const defaultProps$a = {
  as: "div"
};

const Spinner = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$a, p), ["as", "bsPrefix", "variant", "animation", "size", "class"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "spinner");
  const bsSpinnerPrefix = `${bsPrefix}-${local.animation}`;
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, bsSpinnerPrefix, local.size && `${bsSpinnerPrefix}-${local.size}`, local.variant && `text-${local.variant}`);
    }

  }));
};

var Spinner$1 = Spinner;

const _tmpl$$5 = /*#__PURE__*/template(`<span class="visually-hidden"></span>`, 2);
const defaultProps$9 = {
  toggleLabel: "Toggle dropdown",
  type: "button"
};
/**
 * A convenience component for simple or general use split button dropdowns. Renders a
 * `ButtonGroup` containing a `Button` and a `Button` toggle for the `Dropdown`. All `children`
 * are passed directly to the default `Dropdown.Menu`. This component accepts all of [`Dropdown`'s
 * props](#dropdown-props).
 *
 * _All unknown props are passed through to the `Dropdown` component._
 * The Button `variant`, `size` and `bsPrefix` props are passed to the button and toggle,
 * and menu-related props are passed to the `Dropdown.Menu`
 */

const SplitButton = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$9, p), ["id", "bsPrefix", "size", "variant", "title", "type", "toggleLabel", "children", "onClick", "href", "target", "menuRole", "renderMenuOnMount", "rootCloseEvent"]);
  return createComponent(Dropdown$1, mergeProps$1(props, {
    as: ButtonGroup$1,

    get children() {
      return [createComponent(Button$1, {
        get size() {
          return local.size;
        },

        get variant() {
          return local.variant;
        },

        get disabled() {
          return props.disabled;
        },

        get bsPrefix() {
          return local.bsPrefix;
        },

        get href() {
          return local.href;
        },

        get target() {
          return local.target;
        },

        get onClick() {
          return local.onClick;
        },

        get type() {
          return local.type;
        },

        get children() {
          return local.title;
        }

      }), createComponent(Dropdown$1.Toggle, {
        split: true,

        get id() {
          return local.id;
        },

        get size() {
          return local.size;
        },

        get variant() {
          return local.variant;
        },

        get disabled() {
          return props.disabled;
        },

        get childBsPrefix() {
          return local.bsPrefix;
        },

        get children() {
          const _el$ = _tmpl$$5.cloneNode(true);

          insert(_el$, () => local.toggleLabel);

          return _el$;
        }

      }), createComponent(Dropdown$1.Menu, {
        get role() {
          return local.menuRole;
        },

        get renderOnMount() {
          return local.renderMenuOnMount;
        },

        get rootCloseEvent() {
          return local.rootCloseEvent;
        },

        get children() {
          return local.children;
        }

      })];
    }

  }));
};

var SplitButton$1 = SplitButton;

function createUtilityClass(utilityValues, breakpoints = DEFAULT_BREAKPOINTS) {
  const classes = [];
  Object.entries(utilityValues).forEach(([utilName, utilValue]) => {
    if (utilValue != null) {
      if (typeof utilValue === "object") {
        breakpoints.forEach(brkPoint => {
          // @ts-ignore
          const bpValue = utilValue[brkPoint];

          if (bpValue != null) {
            const infix = brkPoint !== "xs" ? `-${brkPoint}` : "";
            classes.push(`${utilName}${infix}-${bpValue}`);
          }
        });
      } else {
        classes.push(`${utilName}-${utilValue}`);
      }
    }
  });
  return classes;
}

const defaultProps$8 = {
  as: "div"
};

const Stack = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$8, p), ["as", "bsPrefix", "class", "direction", "gap"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, local.direction === "horizontal" ? "hstack" : "vstack");
  const breakpoints = useBootstrapBreakpoints();
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(local.class, bsPrefix, ...createUtilityClass({
        gap: local.gap,
        breakpoints: breakpoints()
      }));
    }

  }));
};

var Stack$1 = Stack;

function getTabTransitionComponent(transition) {
  if (typeof transition === "boolean") {
    return transition ? Fade$1 : undefined;
  }

  return transition;
}

const defaultProps$7 = {};

const TabContainer = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$7, p), ["transition"]);
  return createComponent(Tabs$2, mergeProps$1(props, {
    get transition() {
      return getTabTransitionComponent(local.transition);
    }

  }));
};

var TabContainer$1 = TabContainer;

var TabContent = createWithBsPrefix("tab-content");

const defaultProps$6 = {};

const TabPane = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$6, p), ["bsPrefix", "transition"]);
  const [panelProps, meta] = useTabPanel(mergeProps(props, {
    get transition() {
      return getTabTransitionComponent(local.transition);
    }

  }));
  const [panelLocal, rest] = splitProps(panelProps, ["as", "class", "mountOnEnter", "unmountOnExit"]);
  const prefix = useBootstrapPrefix(local.bsPrefix, "tab-pane");
  const Transition = meta.transition || Fade$1; // We provide an empty the TabContext so `<Nav>`s in `<TabPanel>`s don't
  // conflict with the top level one.

  return createComponent(TabContext.Provider, {
    value: null,

    get children() {
      return createComponent(SelectableContext.Provider, {
        value: null,

        get children() {
          return createComponent(Transition, {
            get ["in"]() {
              return meta.isActive;
            },

            get onEnter() {
              return meta.onEnter;
            },

            get onEntering() {
              return meta.onEntering;
            },

            get onEntered() {
              return meta.onEntered;
            },

            get onExit() {
              return meta.onExit;
            },

            get onExiting() {
              return meta.onExiting;
            },

            get onExited() {
              return meta.onExited;
            },

            get mountOnEnter() {
              return meta.mountOnEnter;
            },

            get unmountOnExit() {
              return meta.unmountOnExit;
            },

            get children() {
              return createComponent(Dynamic, mergeProps$1({
                get component() {
                  return panelLocal.as ?? "div";
                }

              }, rest, {
                ref(r$) {
                  const _ref$ = props.ref;
                  typeof _ref$ === "function" ? _ref$(r$) : props.ref = r$;
                },

                get ["class"]() {
                  return classNames(panelLocal.class, prefix, meta.isActive && "active");
                }

              }));
            }

          });
        }

      });
    }

  });
};

var TabPane$1 = TabPane;

const Tab = props => {
  // special return value expected by Tabs
  return props;
};

var Tab$1 = Object.assign(Tab, {
  Container: TabContainer$1,
  Content: TabContent,
  Pane: TabPane$1
});

const _tmpl$$4 = /*#__PURE__*/template(`<table></table>`, 2),
      _tmpl$2 = /*#__PURE__*/template(`<div></div>`, 2);
const defaultProps$5 = {};

const Table = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$5, p), ["bsPrefix", "class", "striped", "bordered", "borderless", "hover", "size", "variant", "responsive"]);
  const decoratedBsPrefix = useBootstrapPrefix(local.bsPrefix, "table");

  const classes = () => classNames(local.class, decoratedBsPrefix, local.variant && `${decoratedBsPrefix}-${local.variant}`, local.size && `${decoratedBsPrefix}-${local.size}`, local.striped && `${decoratedBsPrefix}-striped`, local.bordered && `${decoratedBsPrefix}-bordered`, local.borderless && `${decoratedBsPrefix}-borderless`, local.hover && `${decoratedBsPrefix}-hover`);

  const table = () => (() => {
    const _el$ = _tmpl$$4.cloneNode(true);

    spread(_el$, mergeProps$1(props, {
      get ["class"]() {
        return classes();
      }

    }), false, false);

    return _el$;
  })();

  if (local.responsive) {
    let responsiveClass = `${decoratedBsPrefix}-responsive`;

    if (typeof local.responsive === "string") {
      responsiveClass = `${responsiveClass}-${local.responsive}`;
    }

    return (() => {
      const _el$2 = _tmpl$2.cloneNode(true);

      className(_el$2, responsiveClass);

      insert(_el$2, table);

      return _el$2;
    })();
  }

  return table;
};

var Table$1 = Table;

const defaultProps$4 = {
  variant: "tabs",
  mountOnEnter: false,
  unmountOnExit: false
};

function getDefaultActiveKey(tabs) {
  let defaultActiveKey = undefined;
  tabs.forEach(tab => {
    if (defaultActiveKey == null) {
      defaultActiveKey = tab.eventKey;
    }
  });
  return defaultActiveKey;
}

function RenderTab(props) {
  if (props.title == null) {
    return null;
  }

  return createComponent(NavItem, {
    as: "li",
    role: "presentation",

    get children() {
      return createComponent(NavLink$1, mergeProps$1({
        as: "button",
        type: "button",

        get eventKey() {
          return props.eventKey;
        },

        get disabled() {
          return props.disabled;
        },

        get id() {
          return props.id;
        },

        get ["class"]() {
          return props.tabClass;
        }

      }, () => props.tabAttrs || {}, {
        get children() {
          return props.title;
        }

      }));
    }

  });
}

const Tabs = p => {
  const tabsAccessor = children(() => p.children);
  const tabs = createMemo(() => {
    const t = tabsAccessor();
    return Array.isArray(t) ? t : [t];
  });
  const [local, props] = splitProps(mergeProps({
    get activeKey() {
      return getDefaultActiveKey(tabs());
    }

  }, defaultProps$4, p), ["id", "onSelect", "transition", "mountOnEnter", "unmountOnExit", "children", "activeKey", "defaultActiveKey", "mountOnEnter"]);
  const [activeKey, onSelect] = createControlledProp(() => p.activeKey, () => p.defaultActiveKey ?? local.defaultActiveKey, local.onSelect);
  return createComponent(Tabs$2, {
    get id() {
      return local.id;
    },

    get activeKey() {
      return activeKey();
    },

    onSelect: onSelect,

    get transition() {
      return getTabTransitionComponent(local.transition);
    },

    get mountOnEnter() {
      return local.mountOnEnter;
    },

    get unmountOnExit() {
      return local.unmountOnExit;
    },

    get children() {
      return [createComponent(Nav$1, mergeProps$1(props, {
        role: "tablist",
        as: "ul",

        get children() {
          return createComponent(For, {
            get each() {
              return tabs();
            },

            children: tabProps => createComponent(RenderTab, tabProps)
          });
        }

      })), createComponent(TabContent, {
        get children() {
          return createComponent(For, {
            get each() {
              return tabs();
            },

            children: tabProps => {
              const [_, childProps] = splitProps(tabProps, ["title", "disabled", "tabClass", "tabAttrs"]);
              return createComponent(TabPane$1, childProps);
            }
          });
        }

      })];
    }

  });
};

var Tabs$1 = Tabs;

const fadeStyles = {
  [ENTERING]: "showing",
  [EXITING]: "showing show"
};

const ToastFade = props => createComponent(Fade$1, mergeProps$1(props, {
  transitionClasses: fadeStyles
}));

var ToastFade$1 = ToastFade;

const ToastContext = createContext({
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  onClose() {}

});
var ToastContext$1 = ToastContext;

const _tmpl$$3 = /*#__PURE__*/template(`<div></div>`, 2);
const defaultProps$3 = {
  closeLabel: "Close",
  closeButton: true
};

const ToastHeader = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$3, p), ["bsPrefix", "closeLabel", "closeVariant", "closeButton", "class", "children"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "toast-header");
  const context = useContext(ToastContext$1);

  const handleClick = e => {
    context?.onClose?.(e);
  };

  return (() => {
    const _el$ = _tmpl$$3.cloneNode(true);

    spread(_el$, mergeProps$1(props, {
      get ["class"]() {
        return classNames(bsPrefix, local.class);
      }

    }), false, true);

    insert(_el$, () => local.children, null);

    insert(_el$, (() => {
      const _c$ = memo(() => !!local.closeButton);

      return () => _c$() && createComponent(CloseButton$1, {
        get ["aria-label"]() {
          return local.closeLabel;
        },

        get variant() {
          return local.closeVariant;
        },

        onClick: handleClick,
        "data-dismiss": "toast"
      });
    })(), null);

    return _el$;
  })();
};

var ToastHeader$1 = ToastHeader;

var ToastBody = createWithBsPrefix("toast-body");

const _tmpl$$2 = /*#__PURE__*/template(`<div></div>`, 2);
const defaultProps$2 = {
  transition: ToastFade$1,
  show: true,
  animation: true,
  delay: 5000,
  autohide: false
};

const Toast = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$2, p), ["bsPrefix", "class", "transition", "show", "animation", "delay", "autohide", "onClose", "bg"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "toast"); // We use refs for these, because we don't want to restart the autohide
  // timer in case these values change.

  let delayRef = local.delay;
  let onCloseRef = local.onClose;
  createEffect(() => {
    delayRef = local.delay;
    onCloseRef = local.onClose;
  });
  let autohideTimeout;
  const autohideToast = createMemo(() => !!(local.autohide && local.show));
  const autohideFunc = createMemo(() => () => {
    if (autohideToast()) {
      onCloseRef?.();
    }
  });
  createEffect(() => {
    // Only reset timer if show or autohide changes.
    if (autohideToast()) {
      window.clearTimeout(autohideTimeout);
      autohideTimeout = window.setTimeout(autohideFunc(), delayRef);
    }
  });
  onCleanup(() => {
    window.clearTimeout(autohideTimeout);
  });
  const toastContext = {
    get onClose() {
      return local.onClose;
    }

  };
  const hasAnimation = !!(local.transition && local.animation);
  const Transition = local.transition;

  const ToastInner = () => (() => {
    const _el$ = _tmpl$$2.cloneNode(true);

    spread(_el$, mergeProps$1(props, {
      get ["class"]() {
        return classNames(bsPrefix, local.class, local.bg && `bg-${local.bg}`, !hasAnimation && (local.show ? "show" : "hide"));
      },

      "role": "alert",
      "aria-live": "assertive",
      "aria-atomic": "true"
    }), false, false);

    return _el$;
  })();

  return createComponent(ToastContext$1.Provider, {
    value: toastContext,

    get children() {
      return memo(() => !!(hasAnimation && local.transition))() ? createComponent(Transition, {
        appear: true,

        get ["in"]() {
          return local.show;
        },

        unmountOnExit: true,

        get children() {
          return createComponent(ToastInner, {});
        }

      }) : createComponent(ToastInner, {});
    }

  });
};

var Toast$1 = Object.assign(Toast, {
  Body: ToastBody,
  Header: ToastHeader$1
});

const positionClasses = {
  "top-start": "top-0 start-0",
  "top-center": "top-0 start-50 translate-middle-x",
  "top-end": "top-0 end-0",
  "middle-start": "top-50 start-0 translate-middle-y",
  "middle-center": "top-50 start-50 translate-middle",
  "middle-end": "top-50 end-0 translate-middle-y",
  "bottom-start": "bottom-0 start-0",
  "bottom-center": "bottom-0 start-50 translate-middle-x",
  "bottom-end": "bottom-0 end-0"
};
const defaultProps$1 = {
  as: "div"
};

const ToastContainer = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$1, p), ["as", "bsPrefix", "position", "class"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "toast-container");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, {
    get ["class"]() {
      return classNames(bsPrefix, local.position && `position-absolute ${positionClasses[local.position]}`, local.class);
    }

  }));
};

var ToastContainer$1 = ToastContainer;

const _tmpl$$1 = /*#__PURE__*/template(`<input autocomplete="off">`, 1);

const noop = () => undefined;

const ToggleButton = p => {
  const [local, props] = splitProps(p, ["bsPrefix", "name", "class", "checked", "type", "onChange", "value", "disabled", "id", "inputRef"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "btn-check");
  return [(() => {
    const _el$ = _tmpl$$1.cloneNode(true);

    addEventListener$1(_el$, "change", local.onChange || noop);

    const _ref$ = local.inputRef;
    typeof _ref$ === "function" ? use(_ref$, _el$) : local.inputRef = _el$;

    className(_el$, bsPrefix);

    effect(_p$ => {
      const _v$ = local.name,
            _v$2 = local.type,
            _v$3 = !!local.disabled,
            _v$4 = local.id;

      _v$ !== _p$._v$ && setAttribute(_el$, "name", _p$._v$ = _v$);
      _v$2 !== _p$._v$2 && setAttribute(_el$, "type", _p$._v$2 = _v$2);
      _v$3 !== _p$._v$3 && (_el$.disabled = _p$._v$3 = _v$3);
      _v$4 !== _p$._v$4 && setAttribute(_el$, "id", _p$._v$4 = _v$4);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined,
      _v$3: undefined,
      _v$4: undefined
    });

    effect(() => _el$.value = local.value);

    effect(() => _el$.checked = !!local.checked);

    return _el$;
  })(), createComponent(Button$1, mergeProps$1(props, {
    get ["class"]() {
      return classNames(local.class, local.disabled && "disabled");
    },

    type: undefined,
    role: undefined,
    as: "label",

    get htmlFor() {
      return local.id;
    }

  }))];
};

var ToggleButton$1 = ToggleButton;

const _tmpl$ = /*#__PURE__*/template(`<div role="tooltip"><div class="tooltip-arrow"></div><div></div></div>`, 6);
const defaultProps = {
  arrowProps: {},
  placement: "right"
};

const Tooltip = p => {
  const [local, props] = splitProps(mergeProps(defaultProps, p), ["bsPrefix", "placement", "class", "style", "children", "arrowProps", "popper", "show"]);
  const bsPrefix = useBootstrapPrefix(local.bsPrefix, "tooltip");
  const context = useContext(OverlayContext$1);

  const primaryPlacement = () => (context?.metadata?.placement || local.placement)?.split("-")?.[0];

  return (() => {
    const _el$ = _tmpl$.cloneNode(true),
          _el$2 = _el$.firstChild,
          _el$3 = _el$2.nextSibling;

    spread(_el$, mergeProps$1({
      get ["x-placement"]() {
        return primaryPlacement();
      },

      get ["class"]() {
        return classNames(local.class, bsPrefix, `bs-tooltip-auto`);
      }

    }, props, () => context?.wrapperProps, {
      get style() {
        return Object.assign({}, local.style, context?.wrapperProps.style);
      }

    }), false, true);

    spread(_el$2, mergeProps$1(() => local.arrowProps, () => context?.arrowProps), false, false);

    className(_el$3, `${bsPrefix}-inner`);

    insert(_el$3, () => local.children);

    return _el$;
  })();
};

var Tooltip$1 = Tooltip;

export { Accordion$1 as Accordion, AccordionBody$1 as AccordionBody, AccordionButton$1 as AccordionButton, AccordionCollapse$1 as AccordionCollapse, AccordionContext, AccordionHeader$1 as AccordionHeader, AccordionItem$1 as AccordionItem, AccordionItemContext, Alert$1 as Alert, Badge$1 as Badge, BootstrapModalManager$1 as BootstrapModalManager, Breadcrumb$1 as Breadcrumb, BreadcrumbItem$1 as BreadcrumbItem, Button$1 as Button, ButtonGroup$1 as ButtonGroup, ButtonToolbar$1 as ButtonToolbar, Card$1 as Card, CardGroup, CardHeader$1 as CardHeader, CardHeaderContext, CardImg$1 as CardImg, Carousel$1 as Carousel, CarouselCaption, CarouselItem$1 as CarouselItem, CloseButton$1 as CloseButton, Col$1 as Col, Collapse$1 as Collapse, Container$1 as Container, Dropdown$1 as Dropdown, DropdownButton$1 as DropdownButton, DropdownContext$1 as DropdownContext, DropdownItem$1 as DropdownItem, DropdownMenu$1 as DropdownMenu, DropdownToggle$1 as DropdownToggle, Fade$1 as Fade, Feedback$1 as Feedback, Figure$1 as Figure, FigureCaption$1 as FigureCaption, FigureImage$1 as FigureImage, FloatingLabel$1 as FloatingLabel, Form$1 as Form, FormCheck$1 as FormCheck, FormCheckInput$1 as FormCheckInput, FormCheckLabel$1 as FormCheckLabel, FormContext$1 as FormContext, FormControl$1 as FormControl, FormFloating, FormGroup$1 as FormGroup, FormLabel$1 as FormLabel, FormRange$1 as FormRange, FormSelect$1 as FormSelect, FormText$1 as FormText, Image$1 as Image, InputGroup$1 as InputGroup, InputGroupContext, ListGroup$1 as ListGroup, ListGroupItem$1 as ListGroupItem, Modal$1 as Modal, ModalBody, ModalContext$1 as ModalContext, ModalDialog$1 as ModalDialog, ModalFooter, ModalHeader$1 as ModalHeader, ModalTitle, Nav$1 as Nav, NavContext$1 as NavContext, NavDropdown$1 as NavDropdown, NavItem, NavLink$1 as NavLink, Navbar$1 as Navbar, NavbarBrand$1 as NavbarBrand, NavbarCollapse$1 as NavbarCollapse, NavbarContext, NavbarOffcanvas$1 as NavbarOffcanvas, NavbarToggle$1 as NavbarToggle, Offcanvas$1 as Offcanvas, OffcanvasBody, OffcanvasHeader$1 as OffcanvasHeader, OffcanvasTitle, OffcanvasToggling$1 as OffcanvasToggling, Overlay$1 as Overlay, OverlayContext$1 as OverlayContext, OverlayTrigger, PageItem$1 as PageItem, Pagination$1 as Pagination, Placeholder$1 as Placeholder, PlaceholderButton$1 as PlaceholderButton, Popover$1 as Popover, PopoverBody, PopoverHeader, ProgressBar$1 as ProgressBar, Row$1 as Row, Spinner$1 as Spinner, SplitButton$1 as SplitButton, Stack$1 as Stack, Switch$1 as Switch, Tab$1 as Tab, TabContainer$1 as TabContainer, TabContent, TabPane$1 as TabPane, Table$1 as Table, Tabs$1 as Tabs, ThemeProvider, Toast$1 as Toast, ToastBody, ToastContainer$1 as ToastContainer, ToastContext$1 as ToastContext, ToastFade$1 as ToastFade, ToastHeader$1 as ToastHeader, ToggleButton$1 as ToggleButton, Tooltip$1 as Tooltip, TransitionWrapper$1 as TransitionWrapper };
