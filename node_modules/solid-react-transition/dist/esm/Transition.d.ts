import { Component, JSX } from "solid-js";
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */
export declare const UNMOUNTED = "unmounted";
export declare const EXITED = "exited";
export declare const ENTERING = "entering";
export declare const ENTERED = "entered";
export declare const EXITING = "exiting";
export type TransitionStatus = typeof ENTERING | typeof ENTERED | typeof EXITING | typeof EXITED | typeof UNMOUNTED;
export type TransitionComponent = Component<TransitionProps>;
/**
 * EnterCallback (and EndCallback) is complicated as the original JS version optionally omits the
 * first (element) parameter depending on whether nodeRef is passed in.
 * So it can technically be either of these:
 * (el: HTMLElement, isAppearing?: boolean) => void
 * (isAppearing?: boolean) => void
 * Typescript seems to get grumpy if we just OR those types so this is a hack...
 */
type EnterCallback = (arg1?: HTMLElement | boolean, arg2?: boolean) => void;
type EndCallback = (arg1?: HTMLElement | (() => void), arg2?: () => void) => void;
export type TransitionCallbacks = {
    onEnter?: EnterCallback;
    onEntering?: EnterCallback;
    onEntered?: EnterCallback;
    onExit?: (el: HTMLElement) => void;
    onExiting?: (el: HTMLElement) => void;
    onExited?: (e?: HTMLElement) => void;
};
export type TransitionProps = {
    nodeRef?: HTMLElement;
    children?: JSX.Element | ((status: TransitionStatus | null, childProps: any) => JSX.Element);
    in?: boolean;
    mountOnEnter?: boolean;
    unmountOnExit?: boolean;
    appear?: boolean;
    enter?: boolean;
    exit?: boolean;
    timeout?: number | {
        appear?: number;
        enter?: number;
        exit?: number;
    };
    addEndListener?: EndCallback;
} & TransitionCallbacks;
export declare const Transition: (p: TransitionProps) => JSX.Element;
export {};
