/* eslint-disable @typescript-eslint/no-use-before-define, react/prop-types */
import activeElement from "dom-helpers/activeElement";
import contains from "dom-helpers/contains";
import canUseDOM from "dom-helpers/canUseDOM";
import listen from "dom-helpers/listen";
import ModalManager from "./ModalManager";
import useWindow from "./useWindow";
import { children, createComputed, createEffect, createSignal, mergeProps, on, onCleanup, onMount, splitProps, Show, createMemo, getOwner, runWithOwner, } from "solid-js";
import { Portal } from "solid-js/web";
import useWaitForDOMRef from "./useWaitForDOMRef";
let manager;
function getManager(window) {
    if (!manager)
        manager = new ModalManager({ ownerDocument: window?.document });
    return manager;
}
function useModalManager(provided) {
    const window = useWindow();
    const modalManager = provided || getManager(window);
    const modal = {
        dialog: null,
        backdrop: null,
    };
    return Object.assign(modal, {
        add: () => modalManager.add(modal),
        remove: () => modalManager.remove(modal),
        isTopModal: () => modalManager.isTopModal(modal),
        setDialogRef: (ref) => {
            modal.dialog = ref;
        },
        setBackdropRef: (ref) => {
            modal.backdrop = ref;
        },
    });
}
const defaultProps = {
    show: false,
    role: "dialog",
    backdrop: true,
    keyboard: true,
    autoFocus: true,
    enforceFocus: true,
    restoreFocus: true,
    renderBackdrop: (props) => <div {...props}/>,
    onHide: () => { },
};
export const Modal = (p) => {
    const [local, props] = splitProps(mergeProps(defaultProps, p), 
    // split off local props with rest passed as dialogProps
    [
        "show",
        "role",
        "class",
        "style",
        "children",
        "backdrop",
        "keyboard",
        "onBackdropClick",
        "onEscapeKeyDown",
        "transition",
        "backdropTransition",
        "autoFocus",
        "enforceFocus",
        "restoreFocus",
        "restoreFocusOptions",
        "renderDialog",
        "renderBackdrop",
        "manager",
        "container",
        "onShow",
        "onHide",
        "onExit",
        "onExited",
        "onExiting",
        "onEnter",
        "onEntering",
        "onEntered",
        "ref",
    ]);
    const container = useWaitForDOMRef({
        get ref() {
            return local.container;
        },
    });
    const modal = useModalManager(local.manager);
    const owner = getOwner();
    const [isMounted, setIsMounted] = createSignal(false);
    onMount(() => setIsMounted(true));
    onCleanup(() => setIsMounted(false));
    const [exited, setExited] = createSignal(!local.show);
    let lastFocusRef = null;
    local.ref?.(modal);
    createComputed(on(() => local.show, (show, prevShow) => {
        if (canUseDOM && !prevShow && show) {
            lastFocusRef = activeElement();
        }
    }));
    createComputed(() => {
        if (!local.transition && !local.show && !exited()) {
            setExited(true);
        }
        else if (local.show && exited()) {
            setExited(false);
        }
    });
    const handleShow = () => {
        modal.add();
        removeKeydownListenerRef = listen(document, "keydown", handleDocumentKeyDown);
        removeFocusListenerRef = listen(document, "focus", 
        // the timeout is necessary b/c this will run before the new modal is mounted
        // and so steals focus from it
        () => setTimeout(handleEnforceFocus), true);
        if (local.onShow) {
            local.onShow();
        }
        // autofocus after onShow to not trigger a focus event for previous
        // modals before this one is shown.
        if (local.autoFocus) {
            const currentActiveElement = activeElement(document);
            if (modal.dialog && currentActiveElement && !contains(modal.dialog, currentActiveElement)) {
                lastFocusRef = currentActiveElement;
                modal.dialog.focus();
            }
        }
    };
    const handleHide = () => {
        modal.remove();
        removeKeydownListenerRef?.();
        removeFocusListenerRef?.();
        if (local.restoreFocus) {
            // Support: <=IE11 doesn't support `focus()` on svg elements (RB: #917)
            lastFocusRef?.focus?.(local.restoreFocusOptions);
            lastFocusRef = null;
        }
    };
    // TODO: try and combine these effects: https://github.com/react-bootstrap/react-overlays/pull/794#discussion_r409954120
    // Show logic when:
    //  - show is `true` _and_ `container` has resolved
    createEffect(() => {
        if (!local.show || !container?.())
            return;
        handleShow();
    });
    // Hide cleanup logic when:
    //  - `exited` switches to true
    //  - component unmounts;
    createEffect(on(exited, (exited, prev) => {
        if (exited && !(prev ?? exited)) {
            handleHide();
        }
    }));
    onCleanup(() => {
        handleHide();
    });
    // --------------------------------
    const handleEnforceFocus = () => {
        if (!local.enforceFocus || !isMounted() || !modal.isTopModal()) {
            return;
        }
        const currentActiveElement = activeElement();
        if (modal.dialog && currentActiveElement && !contains(modal.dialog, currentActiveElement)) {
            modal.dialog.focus();
        }
    };
    const handleBackdropClick = (e) => {
        if (e.target !== e.currentTarget) {
            return;
        }
        local.onBackdropClick?.(e);
        if (local.backdrop === true) {
            local.onHide?.();
        }
    };
    const handleDocumentKeyDown = (e) => {
        if (local.keyboard && e.keyCode === 27 && modal.isTopModal()) {
            local.onEscapeKeyDown?.(e);
            if (!e.defaultPrevented) {
                local.onHide?.();
            }
        }
    };
    let removeFocusListenerRef;
    let removeKeydownListenerRef;
    const handleHidden = (...args) => {
        setExited(true);
        local.onExited?.(...args);
    };
    const dialogVisible = createMemo(() => !!(local.show || (local.transition && !exited())));
    const dialogProps = mergeProps({
        get role() {
            return local.role;
        },
        get ref() {
            return modal.setDialogRef;
        },
        // apparently only works on the dialog role element
        get "aria-modal"() {
            return local.role === "dialog" ? true : undefined;
        },
    }, props, {
        get style() {
            return local.style;
        },
        get class() {
            return local.class;
        },
        tabIndex: -1,
    });
    const getChildAsDocument = () => {
        const c = children(() => local.children);
        c()?.setAttribute?.("role", "document");
        return c;
    };
    let innerDialog = () => runWithOwner(owner, () => local.renderDialog ? (local.renderDialog(dialogProps)) : (<div {...dialogProps}>{getChildAsDocument}</div>));
    const Dialog = () => {
        const Transition = local.transition;
        return !Transition ? (innerDialog) : (<Transition appear unmountOnExit in={!!local.show} onExit={local.onExit} onExiting={local.onExiting} onExited={handleHidden} onEnter={local.onEnter} onEntering={local.onEntering} onEntered={local.onEntered}>
        {innerDialog}
      </Transition>);
    };
    const Backdrop = () => {
        let backdropElement = null;
        if (local.backdrop) {
            const BackdropTransition = local.backdropTransition;
            backdropElement = local.renderBackdrop({
                ref: modal.setBackdropRef,
                onClick: handleBackdropClick,
            });
            if (BackdropTransition) {
                backdropElement = (<BackdropTransition appear in={!!local.show}>
            {backdropElement}
          </BackdropTransition>);
            }
        }
        return backdropElement;
    };
    return (<Show when={container() && dialogVisible()}>
      <Portal mount={container()}>
        <Backdrop />
        <Dialog />
      </Portal>
    </Show>);
};
export default Object.assign(Modal, {
    Manager: ModalManager,
});
