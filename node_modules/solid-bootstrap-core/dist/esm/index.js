import { createComponent, Dynamic, mergeProps as mergeProps$1, spread, template, memo, isServer, Portal, insert } from 'solid-js/web';
import { mergeProps, createMemo, splitProps, createContext, createSignal, on, createEffect, onCleanup, $PROXY, $TRACK, getListener, batch, useContext, createComputed, getOwner, onMount, Show, runWithOwner, children } from 'solid-js';
import { popperGenerator, hide, popperOffsets, computeStyles, eventListeners, offset, flip, preventOverflow, arrow } from '@popperjs/core';
import { ENTERED } from 'solid-react-transition';

/**
 * Solid event handlers can be a plain callback OR a tuple [handler, item].
 * This function calls the handler appropriately (if defined).
 */
function callEventHandler(h, e) {
  // capture if propagationStopped
  let isPropagationStopped = false;
  const defaultFn = e.stopPropagation;

  e.stopPropagation = () => {
    isPropagationStopped = true;
    defaultFn();
  }; // call Solid handler appropriately


  if (typeof h === "function") {
    h(e);
  } else if (Array.isArray(h)) {
    h[0](h[1], e);
  }

  e.stopPropagation = defaultFn;
  return {
    isPropagationStopped
  };
}
function resolveClasses(el, prev, now) {
  const p = prev ? prev.split(" ") : [];
  const n = now ? now.split(" ") : [];
  el.classList?.remove(...p.filter(s => n.indexOf(s) === -1));
  el.classList?.add(...n.filter(s => p.indexOf(s) === -1));
}

function isTrivialHref$1(href) {
  return !href || href.trim() === "#";
}
const defaultOptions = {
  tabIndex: 0
};
function useButtonProps(o) {
  const options = mergeProps(defaultOptions, o);
  const tagName = createMemo(() => {
    if (!options.tagName) {
      if (options.href != null || options.target != null || options.rel != null) {
        return "a";
      } else {
        return "button";
      }
    }

    return options.tagName;
  });
  const meta = {
    get tagName() {
      return tagName();
    }

  };

  if (tagName() === "button") {
    return [{
      get type() {
        return options.type || "button";
      },

      get disabled() {
        return options.disabled;
      }

    }, meta];
  }

  const getClickHandler = createMemo(() => event => {
    if (options.disabled || tagName() === "a" && isTrivialHref$1(options.href)) {
      event.preventDefault();
    }

    if (options.disabled) {
      event.stopPropagation();
      return;
    }

    callEventHandler(options.onClick, event);
  });
  const getKeyDownHandler = createMemo(() => event => {
    if (event.key === " ") {
      event.preventDefault();
      getClickHandler()(event
      /*HACK calling click handler with keyboard event*/
      );
    }
  });

  const getHref = () => {
    if (tagName() === "a") {
      // Ensure there's a href so Enter can trigger anchor button.
      return options.disabled ? undefined : options.href || "#";
    }

    return options.href;
  };

  return [{
    role: "button",
    // explicitly undefined so that it overrides the props disabled in a spread
    // e.g. <Tag {...props} {...hookProps} />
    disabled: undefined,

    get tabIndex() {
      return options.disabled ? undefined : options.tabIndex;
    },

    get href() {
      return getHref();
    },

    get target() {
      return tagName() === "a" ? options.target : undefined;
    },

    get "aria-disabled"() {
      return !options.disabled ? undefined : options.disabled;
    },

    get rel() {
      return tagName() === "a" ? options.rel : undefined;
    },

    get onClick() {
      return getClickHandler();
    },

    get onKeyDown() {
      return getKeyDownHandler();
    }

  }, meta];
}
const Button = props => {
  const [local, otherProps] = splitProps(props, ["as"]);
  props.tabIndex;
  const [buttonProps, {
    tagName
  }] = useButtonProps({
    tagName: local.as,
    ...otherProps
  });
  return createComponent(Dynamic, mergeProps$1(otherProps, buttonProps, {
    component: tagName
  }));
};
var Button$1 = Button;

const _tmpl$$1 = /*#__PURE__*/template(`<a></a>`, 2);
function isTrivialHref(href) {
  return !href || href.trim() === "#";
}

/**
 * An generic `<a>` component that covers a few A11y cases, ensuring that
 * cases where the `href` is missing or trivial like "#" are treated like buttons.
 */
const Anchor = props => {
  const [local, otherProps] = splitProps(props, ["onKeyDown"]);
  const [buttonProps] = useButtonProps(mergeProps({
    tagName: "a"
  }, otherProps));

  const handleKeyDown = e => {
    callEventHandler(buttonProps.onKeyDown, e);
    callEventHandler(local.onKeyDown, e);
  };

  return isTrivialHref(props.href) && !props.role || props.role === "button" ? (() => {
    const _el$ = _tmpl$$1.cloneNode(true);

    spread(_el$, mergeProps$1(otherProps, buttonProps, {
      "onKeyDown": handleKeyDown
    }), false, false);

    return _el$;
  })() : (() => {
    const _el$2 = _tmpl$$1.cloneNode(true);

    spread(_el$2, mergeProps$1(otherProps, {
      get onKeyDown() {
        return local.onKeyDown;
      }

    }), false, false);

    return _el$2;
  })();
};
var Anchor$1 = Anchor;

var toArray = Function.prototype.bind.call(Function.prototype.call, [].slice);
/**
 * Runs `querySelectorAll` on a given element.
 * 
 * @param element the element
 * @param selector the selector
 */

function qsa(element, selector) {
  return toArray(element.querySelectorAll(selector));
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/* eslint-disable no-return-assign */
var optionsSupported = false;
var onceSupported = false;

try {
  var options = {
    get passive() {
      return optionsSupported = true;
    },

    get once() {
      // eslint-disable-next-line no-multi-assign
      return onceSupported = optionsSupported = true;
    }

  };

  if (canUseDOM) {
    window.addEventListener('test', options, options);
    window.removeEventListener('test', options, true);
  }
} catch (e) {
  /* */
}
/**
 * An `addEventListener` ponyfill, supports the `once` option
 * 
 * @param node the element
 * @param eventName the event name
 * @param handle the handler
 * @param options event options
 */


function addEventListener(node, eventName, handler, options) {
  if (options && typeof options !== 'boolean' && !onceSupported) {
    var once = options.once,
        capture = options.capture;
    var wrappedHandler = handler;

    if (!onceSupported && once) {
      wrappedHandler = handler.__once || function onceHandler(event) {
        this.removeEventListener(eventName, onceHandler, capture);
        handler.call(this, event);
      };

      handler.__once = wrappedHandler;
    }

    node.addEventListener(eventName, wrappedHandler, optionsSupported ? options : capture);
  }

  node.addEventListener(eventName, handler, options);
}

const DropdownContext = createContext(null);
var DropdownContext$1 = DropdownContext;

const createPopper = popperGenerator({
  defaultModifiers: [hide, popperOffsets, computeStyles, eventListeners, offset, flip, preventOverflow, arrow]
});

const disabledApplyStylesModifier = {
  name: "applyStyles",
  enabled: false,
  phase: "afterWrite",
  fn: () => undefined
}; // until docjs supports type exports...

const ariaDescribedByModifier = {
  name: "ariaDescribedBy",
  enabled: true,
  phase: "afterWrite",
  effect: ({
    state
  }) => () => {
    const {
      reference,
      popper
    } = state.elements;

    if ("removeAttribute" in reference) {
      const ids = (reference.getAttribute("aria-describedby") || "").split(",").filter(id => id.trim() !== popper.id);
      if (!ids.length) reference.removeAttribute("aria-describedby");else reference.setAttribute("aria-describedby", ids.join(","));
    }
  },
  fn: ({
    state
  }) => {
    const {
      popper,
      reference
    } = state.elements;
    const role = popper.getAttribute("role")?.toLowerCase();

    if (popper.id && role === "tooltip" && "setAttribute" in reference) {
      const ids = reference.getAttribute("aria-describedby");

      if (ids && ids.split(",").indexOf(popper.id) !== -1) {
        return;
      }

      reference.setAttribute("aria-describedby", ids ? `${ids},${popper.id}` : popper.id);
    }
  }
};
const EMPTY_MODIFIERS = [];
/**
 * Position an element relative some reference element using Popper.js
 *
 * @param referenceElement
 * @param popperElement
 * @param {object}      options
 * @param {object=}     options.modifiers Popper.js modifiers
 * @param {boolean=}    options.enabled toggle the popper functionality on/off
 * @param {string=}     options.placement The popper element placement relative to the reference element
 * @param {string=}     options.strategy the positioning strategy
 * @param {function=}   options.onCreate called when the popper is created
 * @param {function=}   options.onUpdate called when the popper is updated
 *
 * @returns {UsePopperState} The popper state accessor
 */

function usePopper(referenceElement, popperElement, options) {
  const [popperInstance, setPopperInstance] = createSignal();
  const enabled = createMemo(() => options.enabled ?? true);
  const update = createMemo(on(popperInstance, popper => () => {
    popper?.update();
  }));
  const forceUpdate = createMemo(on(popperInstance, popper => () => {
    popper?.forceUpdate();
  }));
  const [popperState, setPopperState] = createSignal({
    placement: options.placement ?? "bottom",

    get update() {
      return update();
    },

    get forceUpdate() {
      return forceUpdate();
    },

    attributes: {},
    styles: {
      popper: {},
      arrow: {}
    }
  });
  const updateModifier = {
    name: "updateStateModifier",
    enabled: true,
    phase: "write",
    requires: ["computeStyles"],
    fn: ({
      state
    }) => {
      const styles = {};
      const attributes = {};
      Object.keys(state.elements).forEach(element => {
        styles[element] = state.styles[element];
        attributes[element] = state.attributes[element];
      });
      setPopperState(s => ({ ...s,
        state,
        styles,
        attributes,
        placement: state.placement
      }));
    }
  };
  createEffect(() => {
    const instance = popperInstance();
    if (!instance || !enabled()) return;
    instance.setOptions({
      onFirstUpdate: options.onFirstUpdate,
      placement: options.placement ?? "bottom",
      modifiers: [...(options.modifiers ?? EMPTY_MODIFIERS), ariaDescribedByModifier, updateModifier, disabledApplyStylesModifier],
      strategy: options.strategy ?? "absolute"
    });
    /** Hack to force update as popper doesn't seem to position properly after options change **/

    queueMicrotask(() => {
      update()();
    });
  });
  createEffect(() => {
    const target = referenceElement();
    const popper = popperElement();

    if (target && popper && enabled()) {
      let instance;
      instance = createPopper(target, popper, {});
      setPopperInstance(instance);
    } else {
      if (popperInstance()) {
        popperInstance().destroy();
        setPopperInstance(undefined);
        setPopperState(s => ({ ...s,
          attributes: {},
          styles: {
            popper: {}
          }
        }));
      }
    }
  });
  return popperState;
}

/* eslint-disable no-bitwise, no-cond-assign */

/**
 * Checks if an element contains another given element.
 * 
 * @param context the context element
 * @param node the element to check
 */
function contains(context, node) {
  // HTML DOM and SVG DOM may have different support levels,
  // so we need to check on context instead of a document root element.
  if (context.contains) return context.contains(node);
  if (context.compareDocumentPosition) return context === node || !!(context.compareDocumentPosition(node) & 16);
}

/**
 * A `removeEventListener` ponyfill
 * 
 * @param node the element
 * @param eventName the event name
 * @param handle the handler
 * @param options event options
 */
function removeEventListener(node, eventName, handler, options) {
  var capture = options && typeof options !== 'boolean' ? options.capture : options;
  node.removeEventListener(eventName, handler, capture);

  if (handler.__once) {
    node.removeEventListener(eventName, handler.__once, capture);
  }
}

function listen(node, eventName, handler, options) {
  addEventListener(node, eventName, handler, options);
  return function () {
    removeEventListener(node, eventName, handler, options);
  };
}

/**
 * Returns the owner document of a given element.
 * 
 * @param node the element
 */
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}

const noop$4 = () => {};

function isLeftClickEvent(event) {
  return event.button === 0;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

const getRefTarget = ref => ref;

/**
 * The `useClickOutside` hook registers your callback on the document that fires
 * when a pointer event is registered outside of the provided ref or element.
 *
 * @param {Ref<HTMLElement>| HTMLElement} ref  The element boundary
 * @param {function} onClickOutside
 * @param {object=}  options
 * @param {boolean=} options.disabled
 * @param {string=}  options.clickTrigger The DOM event name (click, mousedown, etc) to attach listeners on
 */
function useClickOutside(ref, onClickOutside = noop$4, {
  disabled,
  clickTrigger = "click"
} = {}) {
  const [preventMouseClickOutsideRef, setPreventMouseClickOutsideRef] = createSignal(false);

  const handleMouseCapture = e => {
    const currentTarget = getRefTarget(ref());
    setPreventMouseClickOutsideRef(!currentTarget || isModifiedEvent(e) || !isLeftClickEvent(e) || !!contains(currentTarget, e.target));
  };

  const handleMouse = e => {
    if (!preventMouseClickOutsideRef()) {
      onClickOutside(e);
    }
  };

  createEffect(() => {
    if (disabled || ref() == null) return undefined;
    const doc = ownerDocument(getRefTarget(ref())); // Store the current event to avoid triggering handlers immediately
    // https://github.com/facebook/react/issues/20074

    let currentEvent = (doc.defaultView || window).event; // Use capture for this listener so it fires before React's listener, to
    // avoid false positives in the contains() check below if the target DOM
    // element is removed in the React mouse callback.

    const removeMouseCaptureListener = listen(doc, clickTrigger, handleMouseCapture, true);
    const removeMouseListener = listen(doc, clickTrigger, e => {
      // skip if this event is the same as the one running when we added the handlers
      if (e === currentEvent) {
        currentEvent = undefined;
        return;
      }

      handleMouse(e);
    });
    let mobileSafariHackListeners = [];

    if ("ontouchstart" in doc.documentElement) {
      mobileSafariHackListeners = [].slice.call(doc.body.children).map(el => listen(el, "mousemove", noop$4));
    }

    onCleanup(() => {
      removeMouseCaptureListener();
      removeMouseListener();
      mobileSafariHackListeners.forEach(remove => remove());
    });
  });
}

function toModifierMap(modifiers) {
  const result = {};

  if (!Array.isArray(modifiers)) {
    return modifiers || result;
  } // eslint-disable-next-line no-unused-expressions


  modifiers?.forEach(m => {
    result[m.name] = m;
  });
  return result;
}
function toModifierArray(map = {}) {
  if (Array.isArray(map)) return map;
  return Object.keys(map).map(k => {
    map[k].name = k;
    return map[k];
  });
}
function mergeOptionsWithPopperConfig({
  enabled,
  enableEvents,
  placement,
  flip,
  offset,
  fixed,
  containerPadding,
  arrowElement,
  popperConfig = {}
}) {
  const modifiers = toModifierMap(popperConfig.modifiers);
  return { ...popperConfig,
    placement,
    enabled,
    strategy: fixed ? "fixed" : popperConfig.strategy,
    modifiers: toModifierArray({ ...modifiers,
      eventListeners: {
        enabled: enableEvents
      },
      preventOverflow: { ...modifiers.preventOverflow,
        options: containerPadding ? {
          padding: containerPadding,
          ...modifiers.preventOverflow?.options
        } : modifiers.preventOverflow?.options
      },
      offset: {
        options: {
          offset,
          ...modifiers.offset?.options
        }
      },
      arrow: { ...modifiers.arrow,
        enabled: !!arrowElement,
        options: { ...modifiers.arrow?.options,
          element: arrowElement
        }
      },
      flip: {
        enabled: !!flip,
        ...modifiers.flip
      }
    })
  };
}

const $RAW = Symbol("store-raw"),
      $NODE = Symbol("store-node"),
      $NAME = Symbol("store-name");

function wrap$1(value, name) {
  let p = value[$PROXY];

  if (!p) {
    Object.defineProperty(value, $PROXY, {
      value: p = new Proxy(value, proxyTraps$1)
    });

    if (!Array.isArray(value)) {
      const keys = Object.keys(value),
            desc = Object.getOwnPropertyDescriptors(value);

      for (let i = 0, l = keys.length; i < l; i++) {
        const prop = keys[i];

        if (desc[prop].get) {
          const get = desc[prop].get.bind(p);
          Object.defineProperty(value, prop, {
            enumerable: desc[prop].enumerable,
            get
          });
        }
      }
    }
  }

  return p;
}

function isWrappable(obj) {
  let proto;
  return obj != null && typeof obj === "object" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));
}

function unwrap(item, set = new Set()) {
  let result, unwrapped, v, prop;
  if (result = item != null && item[$RAW]) return result;
  if (!isWrappable(item) || set.has(item)) return item;

  if (Array.isArray(item)) {
    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);

    for (let i = 0, l = item.length; i < l; i++) {
      v = item[i];
      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;
    }
  } else {
    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);
    const keys = Object.keys(item),
          desc = Object.getOwnPropertyDescriptors(item);

    for (let i = 0, l = keys.length; i < l; i++) {
      prop = keys[i];
      if (desc[prop].get) continue;
      v = item[prop];
      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;
    }
  }

  return item;
}

function getDataNodes(target) {
  let nodes = target[$NODE];
  if (!nodes) Object.defineProperty(target, $NODE, {
    value: nodes = {}
  });
  return nodes;
}

function getDataNode(nodes, property, value) {
  return nodes[property] || (nodes[property] = createDataNode(value));
}

function proxyDescriptor$1(target, property) {
  const desc = Reflect.getOwnPropertyDescriptor(target, property);
  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE || property === $NAME) return desc;
  delete desc.value;
  delete desc.writable;

  desc.get = () => target[$PROXY][property];

  return desc;
}

function trackSelf(target) {
  if (getListener()) {
    const nodes = getDataNodes(target);
    (nodes._ || (nodes._ = createDataNode()))();
  }
}

function ownKeys(target) {
  trackSelf(target);
  return Reflect.ownKeys(target);
}

function createDataNode(value) {
  const [s, set] = createSignal(value, {
    equals: false,
    internal: true
  });
  s.$ = set;
  return s;
}

const proxyTraps$1 = {
  get(target, property, receiver) {
    if (property === $RAW) return target;
    if (property === $PROXY) return receiver;

    if (property === $TRACK) {
      trackSelf(target);
      return receiver;
    }

    const nodes = getDataNodes(target);
    const tracked = nodes.hasOwnProperty(property);
    let value = tracked ? nodes[property]() : target[property];
    if (property === $NODE || property === "__proto__") return value;

    if (!tracked) {
      const desc = Object.getOwnPropertyDescriptor(target, property);
      if (getListener() && (typeof value !== "function" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getDataNode(nodes, property, value)();
    }

    return isWrappable(value) ? wrap$1(value) : value;
  },

  has(target, property) {
    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === "__proto__") return true;
    this.get(target, property, target);
    return property in target;
  },

  set() {
    return true;
  },

  deleteProperty() {
    return true;
  },

  ownKeys: ownKeys,
  getOwnPropertyDescriptor: proxyDescriptor$1
};

function setProperty(state, property, value, deleting = false) {
  if (!deleting && state[property] === value) return;
  const prev = state[property],
        len = state.length;
  if (value === undefined) delete state[property];else state[property] = value;
  let nodes = getDataNodes(state),
      node;
  if (node = getDataNode(nodes, property, prev)) node.$(() => value);
  if (Array.isArray(state) && state.length !== len) (node = getDataNode(nodes, "length", len)) && node.$(state.length);
  (node = nodes._) && node.$();
}

function mergeStoreNode(state, value) {
  const keys = Object.keys(value);

  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];
    setProperty(state, key, value[key]);
  }
}

function updateArray(current, next) {
  if (typeof next === "function") next = next(current);
  next = unwrap(next);

  if (Array.isArray(next)) {
    if (current === next) return;
    let i = 0,
        len = next.length;

    for (; i < len; i++) {
      const value = next[i];
      if (current[i] !== value) setProperty(current, i, value);
    }

    setProperty(current, "length", len);
  } else mergeStoreNode(current, next);
}

function updatePath(current, path, traversed = []) {
  let part,
      prev = current;

  if (path.length > 1) {
    part = path.shift();
    const partType = typeof part,
          isArray = Array.isArray(current);

    if (Array.isArray(part)) {
      for (let i = 0; i < part.length; i++) {
        updatePath(current, [part[i]].concat(path), traversed);
      }

      return;
    } else if (isArray && partType === "function") {
      for (let i = 0; i < current.length; i++) {
        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);
      }

      return;
    } else if (isArray && partType === "object") {
      const {
        from = 0,
        to = current.length - 1,
        by = 1
      } = part;

      for (let i = from; i <= to; i += by) {
        updatePath(current, [i].concat(path), traversed);
      }

      return;
    } else if (path.length > 1) {
      updatePath(current[part], path, [part].concat(traversed));
      return;
    }

    prev = current[part];
    traversed = [part].concat(traversed);
  }

  let value = path[0];

  if (typeof value === "function") {
    value = value(prev, traversed);
    if (value === prev) return;
  }

  if (part === undefined && value == undefined) return;
  value = unwrap(value);

  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {
    mergeStoreNode(prev, value);
  } else setProperty(current, part, value);
}

function createStore(...[store, options]) {
  const unwrappedStore = unwrap(store || {});
  const isArray = Array.isArray(unwrappedStore);
  const wrappedStore = wrap$1(unwrappedStore);

  function setStore(...args) {
    batch(() => {
      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);
    });
  }

  return [wrappedStore, setStore];
}

const $ROOT = Symbol("store-root");

function applyState(target, parent, property, merge, key) {
  const previous = parent[property];
  if (target === previous) return;

  if (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key]) {
    if (target !== previous) {
      if (property === $ROOT) return target;
      setProperty(parent, property, target);
    }

    return;
  }

  if (Array.isArray(target)) {
    if (target.length && previous.length && (!merge || key && target[0][key] != null)) {
      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;

      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start][key] === target[start][key]); start++) {
        applyState(target[start], previous, start, merge, key);
      }

      const temp = new Array(target.length),
            newIndices = new Map();

      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end][key] === target[newEnd][key]); end--, newEnd--) {
        temp[newEnd] = previous[end];
      }

      if (start > newEnd || start > end) {
        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);

        for (; j < target.length; j++) {
          setProperty(previous, j, temp[j]);
          applyState(target[j], previous, j, merge, key);
        }

        if (previous.length > target.length) setProperty(previous, "length", target.length);
        return;
      }

      newIndicesNext = new Array(newEnd + 1);

      for (j = newEnd; j >= start; j--) {
        item = target[j];
        keyVal = key ? item[key] : item;
        i = newIndices.get(keyVal);
        newIndicesNext[j] = i === undefined ? -1 : i;
        newIndices.set(keyVal, j);
      }

      for (i = start; i <= end; i++) {
        item = previous[i];
        keyVal = key ? item[key] : item;
        j = newIndices.get(keyVal);

        if (j !== undefined && j !== -1) {
          temp[j] = previous[i];
          j = newIndicesNext[j];
          newIndices.set(keyVal, j);
        }
      }

      for (j = start; j < target.length; j++) {
        if (j in temp) {
          setProperty(previous, j, temp[j]);
          applyState(target[j], previous, j, merge, key);
        } else setProperty(previous, j, target[j]);
      }
    } else {
      for (let i = 0, len = target.length; i < len; i++) {
        applyState(target[i], previous, i, merge, key);
      }
    }

    if (previous.length > target.length) setProperty(previous, "length", target.length);
    return;
  }

  const targetKeys = Object.keys(target);

  for (let i = 0, len = targetKeys.length; i < len; i++) {
    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);
  }

  const previousKeys = Object.keys(previous);

  for (let i = 0, len = previousKeys.length; i < len; i++) {
    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);
  }
}

function reconcile(value, options = {}) {
  const {
    merge,
    key = "id"
  } = options,
        v = unwrap(value);
  return state => {
    if (!isWrappable(state) || !isWrappable(v)) return v;
    const res = applyState(v, {
      [$ROOT]: state
    }, $ROOT, merge, key);
    return res === undefined ? state : res;
  };
}

const noop$3 = () => {};
/**
 * @memberOf Dropdown
 * @param {object}  options
 * @param {boolean} options.flip Automatically adjust the menu `drop` position based on viewport edge detection
 * @param {[number, number]} options.offset Define an offset distance between the Menu and the Toggle
 * @param {boolean} options.show Display the menu manually, ignored in the context of a `Dropdown`
 * @param {boolean} options.usePopper opt in/out of using PopperJS to position menus. When disabled you must position it yourself.
 * @param {string}  options.rootCloseEvent The pointer event to listen for when determining "clicks outside" the menu for triggering a close.
 * @param {object}  options.popperConfig Options passed to the [`usePopper`](/api/usePopper) hook.
 */


function useDropdownMenu(o = {}) {
  const context = useContext(DropdownContext$1);
  const [arrowElement, attachArrowRef] = createSignal();
  const [hasShownRef, setHasShownRef] = createSignal(false);
  const [popperOptions, setPopperOptions] = createStore({}); // merge in option defaults

  const options = mergeProps({
    fixed: false,
    popperConfig: {},
    usePopper: !!context
  }, o);
  const show = createMemo(() => {
    return context?.show == null ? !!options.show : context.show;
  });
  createEffect(() => {
    if (show() && !hasShownRef()) {
      setHasShownRef(true);
    }
  });
  /** sync popper with options */

  createComputed(() => {
    setPopperOptions(reconcile(mergeOptionsWithPopperConfig({
      placement: options.placement || context?.placement || "bottom-start",
      enabled: options.usePopper ?? !!context,
      enableEvents: options.enableEventListeners == null ? show() : options.enableEventListeners,
      offset: options.offset,
      flip: options.flip,
      fixed: options.fixed,
      arrowElement: arrowElement(),
      popperConfig: options.popperConfig
    })));
  });

  const handleClose = e => {
    context?.toggle(false, e);
  };

  const popper = usePopper(() => context?.toggleElement, () => context?.menuElement, popperOptions);
  createEffect(() => {
    if (context?.menuElement) {
      useClickOutside(() => context.menuElement, handleClose, {
        get clickTrigger() {
          return options.rootCloseEvent;
        },

        get disabled() {
          return !show();
        }

      });
    }
  });
  const menuProps = mergeProps({
    get ref() {
      return context?.setMenu || noop$3;
    },

    get style() {
      return popper()?.styles.popper;
    },

    get "aria-labelledby"() {
      return context?.toggleElement?.id;
    }

  }, popper()?.attributes.popper ?? {});
  const metadata = {
    get show() {
      return show();
    },

    get placement() {
      return context?.placement;
    },

    get hasShown() {
      return hasShownRef();
    },

    get toggle() {
      return context?.toggle;
    },

    get popper() {
      return options.usePopper ? popper() : null;
    },

    get arrowProps() {
      return options.usePopper ? {
        ref: attachArrowRef,
        ...popper()?.attributes.arrow,
        style: popper()?.styles.arrow
      } : {};
    }

  };
  return [menuProps, metadata];
}

/**
 * Also exported as `<Dropdown.Menu>` from `Dropdown`.
 *
 * @displayName DropdownMenu
 * @memberOf Dropdown
 */
function DropdownMenu(p) {
  const [local, options] = splitProps(p, ["children"]);
  const [props, meta] = useDropdownMenu(options);
  return memo(() => local.children(props, meta));
}

// import {
//   useSSRSafeId,
//   useIsSSR,
//   SSRProvider,
//   SSRProviderProps,
// } from '@react-aria/ssr';
// export type { SSRProviderProps };
// export { useSSRSafeId, useIsSSR, SSRProvider };

/* Hacks to replace above from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/ssr/src/SSRProvider.tsx  */
let currentId = 0;
function useSSRSafeId(defaultId) {
  return defaultId || `solid-aria-${++currentId}`;
}

const isRoleMenu = el => el.getAttribute("role")?.toLowerCase() === "menu";

const noop$2 = () => {};
/**
 * Wires up Dropdown toggle functionality, returning a set a props to attach
 * to the element that functions as the dropdown toggle (generally a button).
 *
 * @memberOf Dropdown
 */


function useDropdownToggle() {
  const id = useSSRSafeId();
  const context = useContext(DropdownContext$1);

  const handleClick = e => {
    context.toggle(!context.show, e);
  };

  return [{
    id,

    get ref() {
      return context.setToggle || noop$2;
    },

    onClick: handleClick,

    get "aria-expanded"() {
      return !!context.show;
    },

    get "aria-haspopup"() {
      return context.menuElement && isRoleMenu(context.menuElement) ? true : undefined;
    }

  }, {
    get show() {
      return context.show;
    },

    get toggle() {
      return context.toggle;
    }

  }];
}

/**
 * Also exported as `<Dropdown.Toggle>` from `Dropdown`.
 *
 * @displayName DropdownToggle
 * @memberOf Dropdown
 */
function DropdownToggle({
  children
}) {
  const [props, meta] = useDropdownToggle();
  return memo(() => children(props, meta));
}

const SelectableContext = createContext(null);
const makeEventKey = (eventKey, href = null) => {
  if (eventKey != null) return String(eventKey);
  return href || null;
};
var SelectableContext$1 = SelectableContext;

const NavContext = createContext(null);
var NavContext$1 = NavContext;

const ATTRIBUTE_PREFIX = `data-rr-ui-`;
const PROPERTY_PREFIX = `rrUi`;
function dataAttr(property) {
  return `${ATTRIBUTE_PREFIX}${property}`;
}
function dataProp(property) {
  return `${PROPERTY_PREFIX}${property}`;
}

/**
 * Create a dropdown item. Returns a set of props for the dropdown item component
 * including an `onClick` handler that prevents selection when the item is disabled
 */
function useDropdownItem(options) {
  const onSelectCtx = useContext(SelectableContext$1);
  const navContext = useContext(NavContext$1);
  const {
    activeKey
  } = navContext || {};
  const eventKey = makeEventKey(options.key, options.href);
  const isActive = createMemo(() => options.active == null && options.key != null ? makeEventKey(activeKey) === eventKey : options.active);

  const handleClick = event => {
    if (options.disabled) return;
    let result = callEventHandler(options.onClick, event);

    if (onSelectCtx && !result.isPropagationStopped) {
      onSelectCtx(eventKey, event);
    }
  };

  return [{
    onClick: handleClick,

    get "aria-disabled"() {
      return options.disabled || undefined;
    },

    get "aria-selected"() {
      return isActive();
    },

    [dataAttr("dropdown-item")]: ""
  }, {
    get isActive() {
      return isActive();
    }

  }];
}
const DropdownItem = p => {
  const [local, props] = splitProps( // merge in prop defaults
  mergeProps({
    as: Button$1
  }, p), // split off local props with rest passed to Dynamic
  ["eventKey", "disabled", "onClick", "active", "as"]);
  const [dropdownItemProps] = useDropdownItem({
    get key() {
      return local.eventKey;
    },

    get href() {
      return props.href;
    },

    get disabled() {
      return local.disabled;
    },

    get onClick() {
      return local.onClick;
    },

    get active() {
      return local.active;
    }

  });
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, props, dropdownItemProps));
};
var DropdownItem$1 = DropdownItem;

const Context = createContext(canUseDOM ? window : undefined);
Context.Provider;
/**
 * The document "window" placed in context. Helpful for determining
 * SSR context, or when rendering into an iframe.
 *
 * @returns the current window
 */

function useWindow() {
  return useContext(Context);
}

/**
 * Either returns passed in [value, handler] or creates a signal to control value.
 *
 * @param propValue if controlled
 * @param defaultValue optional default if value not controlled
 * @param handler called in both modes
 * @returns
 */
function createControlledProp(propValue, defaultValue, handler) {
  const [stateValue, setState] = createSignal(defaultValue());
  const isControlled = createMemo(() => propValue() !== undefined);
  /**
   * If a prop switches from controlled to Uncontrolled
   * reset its value to the defaultValue
   */

  createComputed(on(isControlled, (is, was) => {
    if (!is && was && stateValue() !== defaultValue()) {
      setState(() => defaultValue());
    }
  }));

  const getValue = () => isControlled() ? propValue() : stateValue();

  const setValue = (value, ...args) => {
    if (handler) handler(value, ...args);
    setState(() => value);
  };

  return [getValue, setValue];
}

/**
 * @displayName Dropdown
 * @public
 */
function Dropdown(p) {
  // merge in props defaults
  const props = mergeProps({
    itemSelector: `* [${dataAttr("dropdown-item")}]`,
    placement: "bottom-start"
  }, p);
  const window = useWindow();
  const [show, onToggle] = createControlledProp(() => props.show, () => props.defaultShow, props.onToggle);
  const [menuRef, setMenu] = createSignal();
  const [toggleRef, setToggle] = createSignal();
  const [lastSourceEvent, setLastSourceEvent] = createSignal(null);
  const onSelectCtx = useContext(SelectableContext$1);

  const focusInDropdown = () => menuRef()?.contains(menuRef().ownerDocument.activeElement);

  const toggle = (nextShow, event, source = event?.type) => {
    onToggle(nextShow, {
      originalEvent: event,
      source
    });
  };

  const handleSelect = (key, event) => {
    let result = callEventHandler(event => {
      props.onSelect?.(key, event);
      toggle(false, event, "select");
    }, event);

    if (!result.isPropagationStopped) {
      onSelectCtx?.(key, event);
    }
  };

  const context = {
    toggle,
    setMenu,
    setToggle,

    get placement() {
      return props.placement;
    },

    get show() {
      return show();
    },

    get menuElement() {
      return menuRef();
    },

    get toggleElement() {
      return toggleRef();
    }

  };

  const focusToggle = () => {
    const ref = toggleRef();

    if (ref && ref.focus) {
      ref.focus();
    }
  };

  const maybeFocusFirst = () => {
    const type = lastSourceEvent();
    setLastSourceEvent(null);
    let focusType = props.focusFirstItemOnShow;

    if (focusType == null) {
      focusType = menuRef() && isRoleMenu(menuRef()) ? "keyboard" : false;
    }

    if (focusType === false || focusType === "keyboard" && !/^key.+$/.test(type)) {
      return;
    }

    const first = qsa(menuRef(), props.itemSelector)[0];
    if (first && first.focus) first.focus();
  };

  createEffect(() => {
    if (show()) {
      maybeFocusFirst();
    } else if (focusInDropdown()) {
      focusToggle();
    }
  });

  const getNextFocusedChild = (current, offset) => {
    if (!menuRef()) return null;
    const items = qsa(menuRef(), props.itemSelector);
    let index = items.indexOf(current) + offset;
    index = Math.max(0, Math.min(index, items.length));
    return items[index];
  };

  const keydownHandler = event => {
    const {
      key
    } = event;
    const target = event.target;
    const fromMenu = menuRef()?.contains(target);
    const fromToggle = toggleRef()?.contains(target); // Second only to https://github.com/twbs/bootstrap/blob/8cfbf6933b8a0146ac3fbc369f19e520bd1ebdac/js/src/dropdown.js#L400
    // in inscrutability

    const isInput = /input|textarea/i.test(target.tagName);

    if (isInput && (key === " " || key !== "Escape" && fromMenu || key === "Escape" && target.type === "search")) {
      return;
    }

    if (!fromMenu && !fromToggle) {
      return;
    }

    if (key === "Tab" && (!menuRef() || !show)) {
      return;
    }

    setLastSourceEvent(event.type);
    const meta = {
      originalEvent: event,
      source: event.type
    };

    switch (key) {
      case "ArrowUp":
        {
          const next = getNextFocusedChild(target, -1);
          if (next && next.focus) next.focus();
          event.preventDefault();
          return;
        }

      case "ArrowDown":
        event.preventDefault();

        if (!show) {
          onToggle(true, meta);
        } else {
          const next = getNextFocusedChild(target, 1);
          if (next && next.focus) next.focus();
        }

        return;

      case "Tab":
        // on keydown the target is the element being tabbed FROM, we need that
        // to know if this event is relevant to this dropdown (e.g. in this menu).
        // On `keyup` the target is the element being tagged TO which we use to check
        // if focus has left the menu
        if (!isServer) {
          addEventListener(target.ownerDocument, "keyup", e => {
            if (e.key === "Tab" && !e.target || !menuRef()?.contains(e.target)) {
              onToggle(false, meta);
            }
          }, {
            once: true
          });
        }

        break;

      case "Escape":
        if (key === "Escape") {
          event.preventDefault();
          event.stopPropagation();
        }

        onToggle(false, meta);
        focusToggle();
        break;
    }
  };

  if (!isServer) {
    window.document.addEventListener("keydown", keydownHandler);
    onCleanup(() => window.document.removeEventListener("keydown", keydownHandler));
  }

  return createComponent(SelectableContext$1.Provider, {
    value: handleSelect,

    get children() {
      return createComponent(DropdownContext$1.Provider, {
        value: context,

        get children() {
          return props.children;
        }

      });
    }

  });
}
Dropdown.Menu = DropdownMenu;
Dropdown.Toggle = DropdownToggle;
Dropdown.Item = DropdownItem$1;

/**
 * Returns the actively focused element safely.
 *
 * @param doc the document to check
 */

function activeElement(doc) {
  if (doc === void 0) {
    doc = ownerDocument();
  } // Support: IE 9 only
  // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>


  try {
    var active = doc.activeElement; // IE11 returns a seemingly empty object in some cases when accessing
    // document.activeElement from an <iframe>

    if (!active || !active.nodeName) return null;
    return active;
  } catch (e) {
    /* ie throws if no active element */
    return doc.body;
  }
}

/**
 * Returns the owner window of a given element.
 * 
 * @param node the element
 */

function ownerWindow(node) {
  var doc = ownerDocument(node);
  return doc && doc.defaultView || window;
}

/**
 * Returns one or all computed style properties of an element.
 * 
 * @param node the element
 * @param psuedoElement the style property
 */

function getComputedStyle(node, psuedoElement) {
  return ownerWindow(node).getComputedStyle(node, psuedoElement);
}

var rUpper = /([A-Z])/g;
function hyphenate(string) {
  return string.replace(rUpper, '-$1').toLowerCase();
}

/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 * https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/vendor/core/hyphenateStyleName.js
 */
var msPattern = /^ms-/;
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

var supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;
function isTransform(value) {
  return !!(value && supportedTransforms.test(value));
}

function style(node, property) {
  var css = '';
  var transforms = '';

  if (typeof property === 'string') {
    return node.style.getPropertyValue(hyphenateStyleName(property)) || getComputedStyle(node).getPropertyValue(hyphenateStyleName(property));
  }

  Object.keys(property).forEach(function (key) {
    var value = property[key];

    if (!value && value !== 0) {
      node.style.removeProperty(hyphenateStyleName(key));
    } else if (isTransform(key)) {
      transforms += key + "(" + value + ") ";
    } else {
      css += hyphenateStyleName(key) + ": " + value + ";";
    }
  });

  if (transforms) {
    css += "transform: " + transforms + ";";
  }

  node.style.cssText += ";" + css;
}

/**
 * Get the width of the vertical window scrollbar if it's visible
 */
function getBodyScrollbarWidth(ownerDocument = document) {
  const window = ownerDocument.defaultView;
  return Math.abs(window.innerWidth - ownerDocument.documentElement.clientWidth);
}

const OPEN_DATA_ATTRIBUTE = dataAttr("modal-open");
/**
 * Manages a stack of Modals as well as ensuring
 * body scrolling is is disabled and padding accounted for
 */

class ModalManager {
  constructor({
    ownerDocument,
    handleContainerOverflow = true,
    isRTL = false
  } = {}) {
    this.handleContainerOverflow = handleContainerOverflow;
    this.isRTL = isRTL;
    this.modals = [];
    this.ownerDocument = ownerDocument;
  }

  getScrollbarWidth() {
    return getBodyScrollbarWidth(this.ownerDocument);
  }

  getElement() {
    return (this.ownerDocument || document).body;
  }

  setModalAttributes(_modal) {// For overriding
  }

  removeModalAttributes(_modal) {// For overriding
  }

  setContainerStyle(containerState) {
    const style$1 = {
      overflow: "hidden"
    }; // we are only interested in the actual `style` here
    // because we will override it

    const paddingProp = this.isRTL ? "paddingLeft" : "paddingRight";
    const container = this.getElement();
    containerState.style = {
      overflow: container.style.overflow,
      [paddingProp]: container.style[paddingProp]
    };

    if (containerState.scrollBarWidth) {
      // use computed style, here to get the real padding
      // to add our scrollbar width
      style$1[paddingProp] = `${parseInt(style(container, paddingProp) || "0", 10) + containerState.scrollBarWidth}px`;
    }

    container.setAttribute(OPEN_DATA_ATTRIBUTE, "");
    style(container, style$1);
  }

  reset() {
    [...this.modals].forEach(m => this.remove(m));
  }

  removeContainerStyle(containerState) {
    const container = this.getElement();
    container.removeAttribute(OPEN_DATA_ATTRIBUTE);
    Object.assign(container.style, containerState.style);
  }

  add(modal) {
    let modalIdx = this.modals.indexOf(modal);

    if (modalIdx !== -1) {
      return modalIdx;
    }

    modalIdx = this.modals.length;
    this.modals.push(modal);
    this.setModalAttributes(modal);

    if (modalIdx !== 0) {
      return modalIdx;
    }

    this.state = {
      scrollBarWidth: this.getScrollbarWidth(),
      style: {}
    };

    if (this.handleContainerOverflow) {
      this.setContainerStyle(this.state);
    }

    return modalIdx;
  }

  remove(modal) {
    const modalIdx = this.modals.indexOf(modal);

    if (modalIdx === -1) {
      return;
    }

    this.modals.splice(modalIdx, 1); // if that was the last modal in a container,
    // clean up the container

    if (!this.modals.length && this.handleContainerOverflow) {
      this.removeContainerStyle(this.state);
    }

    this.removeModalAttributes(modal);
  }

  isTopModal(modal) {
    return !!this.modals.length && this.modals[this.modals.length - 1] === modal;
  }

}
var ModalManager$1 = ModalManager;

const resolveContainerRef = (ref, document) => {
  if (!canUseDOM) return null;
  if (ref == null) return (document || ownerDocument()).body;
  if (typeof ref === "function") ref = ref();
  if (ref?.nodeType) return ref || null;
  return null;
};
function useWaitForDOMRef(props) {
  const window = useWindow();
  const [resolvedRef, setRef] = createSignal(resolveContainerRef(props.ref, window?.document));
  createEffect(() => {
    if (props.onResolved && resolvedRef()) {
      props.onResolved(resolvedRef());
    }
  });
  createEffect(() => {
    const nextRef = resolveContainerRef(props.ref);

    if (nextRef !== resolvedRef()) {
      setRef(nextRef);
    }
  });
  return resolvedRef;
}

const _tmpl$ = /*#__PURE__*/template(`<div></div>`, 2);
let manager;

function getManager(window) {
  if (!manager) manager = new ModalManager$1({
    ownerDocument: window?.document
  });
  return manager;
}

function useModalManager(provided) {
  const window = useWindow();
  const modalManager = provided || getManager(window);
  const modal = {
    dialog: null,
    backdrop: null
  };
  return Object.assign(modal, {
    add: () => modalManager.add(modal),
    remove: () => modalManager.remove(modal),
    isTopModal: () => modalManager.isTopModal(modal),
    setDialogRef: ref => {
      modal.dialog = ref;
    },
    setBackdropRef: ref => {
      modal.backdrop = ref;
    }
  });
}

const defaultProps$3 = {
  show: false,
  role: "dialog",
  backdrop: true,
  keyboard: true,
  autoFocus: true,
  enforceFocus: true,
  restoreFocus: true,
  renderBackdrop: props => (() => {
    const _el$ = _tmpl$.cloneNode(true);

    spread(_el$, props, false, false);

    return _el$;
  })(),
  onHide: () => {}
};
const Modal = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$3, p), // split off local props with rest passed as dialogProps
  ["show", "role", "class", "style", "children", "backdrop", "keyboard", "onBackdropClick", "onEscapeKeyDown", "transition", "backdropTransition", "autoFocus", "enforceFocus", "restoreFocus", "restoreFocusOptions", "renderDialog", "renderBackdrop", "manager", "container", "onShow", "onHide", "onExit", "onExited", "onExiting", "onEnter", "onEntering", "onEntered", "ref"]);
  const container = useWaitForDOMRef({
    get ref() {
      return local.container;
    }

  });
  const modal = useModalManager(local.manager);
  const owner = getOwner();
  const [isMounted, setIsMounted] = createSignal(false);
  onMount(() => setIsMounted(true));
  onCleanup(() => setIsMounted(false));
  const [exited, setExited] = createSignal(!local.show);
  let lastFocusRef = null;
  local.ref?.(modal);
  createComputed(on(() => local.show, (show, prevShow) => {
    if (canUseDOM && !prevShow && show) {
      lastFocusRef = activeElement();
    }
  }));
  createComputed(() => {
    if (!local.transition && !local.show && !exited()) {
      setExited(true);
    } else if (local.show && exited()) {
      setExited(false);
    }
  });

  const handleShow = () => {
    modal.add();
    removeKeydownListenerRef = listen(document, "keydown", handleDocumentKeyDown);
    removeFocusListenerRef = listen(document, "focus", // the timeout is necessary b/c this will run before the new modal is mounted
    // and so steals focus from it
    () => setTimeout(handleEnforceFocus), true);

    if (local.onShow) {
      local.onShow();
    } // autofocus after onShow to not trigger a focus event for previous
    // modals before this one is shown.


    if (local.autoFocus) {
      const currentActiveElement = activeElement(document);

      if (modal.dialog && currentActiveElement && !contains(modal.dialog, currentActiveElement)) {
        lastFocusRef = currentActiveElement;
        modal.dialog.focus();
      }
    }
  };

  const handleHide = () => {
    modal.remove();
    removeKeydownListenerRef?.();
    removeFocusListenerRef?.();

    if (local.restoreFocus) {
      // Support: <=IE11 doesn't support `focus()` on svg elements (RB: #917)
      lastFocusRef?.focus?.(local.restoreFocusOptions);
      lastFocusRef = null;
    }
  }; // TODO: try and combine these effects: https://github.com/react-bootstrap/react-overlays/pull/794#discussion_r409954120
  // Show logic when:
  //  - show is `true` _and_ `container` has resolved


  createEffect(() => {
    if (!local.show || !container?.()) return;
    handleShow();
  }); // Hide cleanup logic when:
  //  - `exited` switches to true
  //  - component unmounts;

  createEffect(on(exited, (exited, prev) => {
    if (exited && !(prev ?? exited)) {
      handleHide();
    }
  }));
  onCleanup(() => {
    handleHide();
  }); // --------------------------------

  const handleEnforceFocus = () => {
    if (!local.enforceFocus || !isMounted() || !modal.isTopModal()) {
      return;
    }

    const currentActiveElement = activeElement();

    if (modal.dialog && currentActiveElement && !contains(modal.dialog, currentActiveElement)) {
      modal.dialog.focus();
    }
  };

  const handleBackdropClick = e => {
    if (e.target !== e.currentTarget) {
      return;
    }

    local.onBackdropClick?.(e);

    if (local.backdrop === true) {
      local.onHide?.();
    }
  };

  const handleDocumentKeyDown = e => {
    if (local.keyboard && e.keyCode === 27 && modal.isTopModal()) {
      local.onEscapeKeyDown?.(e);

      if (!e.defaultPrevented) {
        local.onHide?.();
      }
    }
  };

  let removeFocusListenerRef;
  let removeKeydownListenerRef;

  const handleHidden = (...args) => {
    setExited(true);
    local.onExited?.(...args);
  };

  const dialogVisible = createMemo(() => !!(local.show || local.transition && !exited()));
  const dialogProps = mergeProps({
    get role() {
      return local.role;
    },

    get ref() {
      return modal.setDialogRef;
    },

    // apparently only works on the dialog role element
    get "aria-modal"() {
      return local.role === "dialog" ? true : undefined;
    }

  }, props, {
    get style() {
      return local.style;
    },

    get class() {
      return local.class;
    },

    tabIndex: -1
  });

  const getChildAsDocument = () => {
    const c = children(() => local.children);
    c()?.setAttribute?.("role", "document");
    return c;
  };

  let innerDialog = () => runWithOwner(owner, () => local.renderDialog ? local.renderDialog(dialogProps) : (() => {
    const _el$2 = _tmpl$.cloneNode(true);

    spread(_el$2, dialogProps, false, true);

    insert(_el$2, getChildAsDocument);

    return _el$2;
  })());

  const Dialog = () => {
    const Transition = local.transition;
    return !Transition ? innerDialog : createComponent(Transition, {
      appear: true,
      unmountOnExit: true,

      get ["in"]() {
        return !!local.show;
      },

      get onExit() {
        return local.onExit;
      },

      get onExiting() {
        return local.onExiting;
      },

      onExited: handleHidden,

      get onEnter() {
        return local.onEnter;
      },

      get onEntering() {
        return local.onEntering;
      },

      get onEntered() {
        return local.onEntered;
      },

      children: innerDialog
    });
  };

  const Backdrop = () => {
    let backdropElement = null;

    if (local.backdrop) {
      const BackdropTransition = local.backdropTransition;
      backdropElement = local.renderBackdrop({
        ref: modal.setBackdropRef,
        onClick: handleBackdropClick
      });

      if (BackdropTransition) {
        backdropElement = createComponent(BackdropTransition, {
          appear: true,

          get ["in"]() {
            return !!local.show;
          },

          children: backdropElement
        });
      }
    }

    return backdropElement;
  };

  return createComponent(Show, {
    get when() {
      return memo(() => !!container())() && dialogVisible();
    },

    get children() {
      return createComponent(Portal, {
        get mount() {
          return container();
        },

        get children() {
          return [createComponent(Backdrop, {}), createComponent(Dialog, {})];
        }

      });
    }

  });
};
var Modal$1 = Object.assign(Modal, {
  Manager: ModalManager$1
});

const TabContext = createContext(null);
var TabContext$1 = TabContext;

function useNavItem(options) {
  const parentOnSelect = useContext(SelectableContext$1);
  const navContext = useContext(NavContext$1);
  const tabContext = useContext(TabContext$1);
  const isActive = createMemo(() => options.active == null && options.key != null ? navContext?.activeKey === options.key : options.active);
  const role = createMemo(() => navContext && !options.role && navContext.role === "tablist" ? "tab" : options.role);
  const onClick = createMemo(() => e => {
    if (options.disabled) return;
    let result = callEventHandler(options.onClick, e);

    if (options.key == null) {
      return;
    }

    if (parentOnSelect && !result.isPropagationStopped) {
      parentOnSelect(options.key, e);
    }
  });
  const props = {
    get role() {
      return role();
    },

    get [dataAttr("event-key")]() {
      return navContext ? options.key : undefined;
    },

    get id() {
      return navContext ? navContext.getControllerId(options.key) : undefined;
    },

    get tabIndex() {
      return role() === "tab" && (options.disabled || !isActive()) ? -1 : undefined;
    },

    get ["aria-controls"]() {
      /**
       * Simplified scenario for `mountOnEnter`.
       *
       * While it would make sense to keep 'aria-controls' for tabs that have been mounted at least
       * once, it would also complicate the code quite a bit, for very little gain.
       * The following implementation is probably good enough.
       *
       * @see https://github.com/react-restart/ui/pull/40#issuecomment-1009971561
       */
      return isActive() || !tabContext?.unmountOnExit && !tabContext?.mountOnEnter ? navContext ? navContext.getControlledId(options.key) : undefined : undefined;
    },

    get ["aria-disabled"]() {
      return role() === "tab" && options.disabled ? true : undefined;
    },

    get ["aria-selected"]() {
      return role() === "tab" && isActive() ? true : undefined;
    },

    get onClick() {
      return onClick();
    }

  };
  const meta = {
    get isActive() {
      return isActive();
    }

  };
  return [props, meta];
}
const defaultProps$2 = {
  as: Button$1
};
const NavItem = p => {
  const [local, options] = splitProps(mergeProps(defaultProps$2, p), ["as", "active", "eventKey"]);
  const [props, meta] = useNavItem(mergeProps({
    get active() {
      return p.active;
    },

    get key() {
      return makeEventKey(p.eventKey, p.href);
    }

  }, options)); // @ts-ignore

  props[dataAttr("active")] = meta.isActive;
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }

  }, options, props));
};
var NavItem$1 = NavItem;

// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop$1 = e => "";

const EVENT_KEY_ATTR = dataAttr("event-key");
const defaultProps$1 = {
  as: "div"
};
const Nav = p => {
  const [local, props] = splitProps(mergeProps(defaultProps$1, p), ["as", "onSelect", "activeKey", "role", "onKeyDown"]); // and don't want to reset the set in the effect

  const [needsRefocusRef, setNeedsRefocusRef] = createSignal(false);
  const [listNode, setListNode] = createSignal(null);
  const parentOnSelect = useContext(SelectableContext$1);
  const tabContext = useContext(TabContext$1);

  const getNextActiveTab = offset => {
    const currentListNode = listNode();
    if (!currentListNode) return null;
    const items = qsa(currentListNode, `[${EVENT_KEY_ATTR}]:not([aria-disabled=true])`);
    const activeChild = currentListNode.querySelector("[aria-selected=true]");
    if (!activeChild || activeChild !== document.activeElement) return null;
    const index = items.indexOf(activeChild);
    if (index === -1) return null;
    let nextIndex = index + offset;
    if (nextIndex >= items.length) nextIndex = 0;
    if (nextIndex < 0) nextIndex = items.length - 1;
    return items[nextIndex];
  };

  const handleSelect = (key, event) => {
    if (key == null) return;
    local.onSelect?.(key, event);
    parentOnSelect?.(key, event);
  };

  const handleKeyDown = event => {
    callEventHandler(local.onKeyDown, event);

    if (!tabContext) {
      return;
    }

    let nextActiveChild;

    switch (event.key) {
      case "ArrowLeft":
      case "ArrowUp":
        nextActiveChild = getNextActiveTab(-1);
        break;

      case "ArrowRight":
      case "ArrowDown":
        nextActiveChild = getNextActiveTab(1);
        break;

      default:
        return;
    }

    if (!nextActiveChild) return;
    event.preventDefault();
    handleSelect(nextActiveChild.dataset[dataProp("EventKey")] || null, event);
    setNeedsRefocusRef(true);
  };

  createEffect(() => {
    if (listNode() && needsRefocusRef()) {
      const activeChild = listNode().querySelector(`[${EVENT_KEY_ATTR}][aria-selected=true]`);
      activeChild?.focus();
    }

    setNeedsRefocusRef(false);
  });

  const mergedRef = r => {
    setListNode(r);

    if (typeof props.ref === "function") {
      props.ref(r);
    }
  };

  const activeKey = () => makeEventKey(tabContext?.activeKey ?? local.activeKey);

  const getRole = () => {
    return local.role || (tabContext ? "tablist" : undefined);
  };

  return createComponent(SelectableContext$1.Provider, {
    value: handleSelect,

    get children() {
      return createComponent(NavContext$1.Provider, {
        value: {
          get role() {
            return getRole();
          },

          // used by NavLink to determine it's role
          get activeKey() {
            return activeKey();
          },

          get getControlledId() {
            return tabContext?.getControlledId || noop$1;
          },

          get getControllerId() {
            return tabContext?.getControllerId || noop$1;
          }

        },

        get children() {
          return createComponent(Dynamic, mergeProps$1({
            get component() {
              return local.as;
            },

            get ["data-active-key"]() {
              return activeKey();
            }

          }, props, {
            onKeyDown: handleKeyDown,
            ref: mergedRef,

            get role() {
              return getRole();
            }

          }));
        }

      });
    }

  });
};
var Nav$1 = Object.assign(Nav, {
  Item: NavItem$1
});

const NoopTransition = props => {
  const resolvedChildren = children(() => props.children);

  const callChild = () => {
    const c = resolvedChildren();
    return typeof c === "function" ? c(ENTERED, {}) : c;
  };

  return memo(callChild);
};
var NoopTransition$1 = NoopTransition;

const escapeKeyCode = 27;

const noop = () => {};

/**
 * The `useRootClose` hook registers your callback on the document
 * when rendered. Powers the `<Overlay/>` component. This is used achieve modal
 * style behavior where your callback is triggered when the user tries to
 * interact with the rest of the document or hits the `esc` key.
 *
 * @param {Ref<HTMLElement>| HTMLElement} ref  The element boundary
 * @param {function} onRootClose
 * @param {object=}  options
 * @param {boolean=} options.disabled
 * @param {string=}  options.clickTrigger The DOM event name (click, mousedown, etc) to attach listeners on
 */
function useRootClose(ref, onRootClose, options = {}) {
  createSignal(false);
  const onClose = onRootClose || noop;
  useClickOutside(ref, onClose, {
    get disabled() {
      return options.disabled;
    },

    get clickTrigger() {
      return options.clickTrigger;
    }

  });

  const handleKeyUp = e => {
    if (e.keyCode === escapeKeyCode) {
      onClose(e);
    }
  };

  createEffect(() => {
    if (options.disabled || ref() == null) return;
    const doc = ownerDocument(ref()); // Store the current event to avoid triggering handlers immediately
    // https://github.com/facebook/react/issues/20074

    let currentEvent = (doc.defaultView || window).event;
    const removeKeyupListener = listen(doc, "keyup", e => {
      // skip if this event is the same as the one running when we added the handlers
      if (e === currentEvent) {
        currentEvent = undefined;
        return;
      }

      handleKeyUp(e);
    });
    onCleanup(() => {
      removeKeyupListener();
    });
  });
}

/**
 * Built on top of `Popper.js`, the overlay component is
 * great for custom tooltip overlays.
 */
const Overlay = props => {
  const [rootElement, attachRef] = createSignal();
  const [arrowElement, attachArrowRef] = createSignal();
  const [exited, setExited] = createSignal(!props.show);
  const container = useWaitForDOMRef({
    get ref() {
      return props.container;
    }

  });
  const [popperOptions, setPopperOptions] = createStore({});
  const popperVisible = createMemo(() => !!(props.show || props.transition && !exited()));
  /** sync popper options with props */

  createComputed(() => {
    setPopperOptions(reconcile(mergeOptionsWithPopperConfig({
      enabled: popperVisible(),
      placement: props.placement,
      enableEvents: popperVisible(),
      containerPadding: props.containerPadding || 5,
      flip: props.flip,
      offset: props.offset,
      arrowElement: arrowElement(),
      popperConfig: props.popperConfig ?? {}
    })));
  });
  const popper = usePopper(props.target, rootElement, popperOptions);
  createComputed(() => {
    if (props.show) {
      if (exited()) setExited(false);
    } else if (!props.transition && !exited()) {
      setExited(true);
    }
  });

  const handleHidden = (...args) => {
    setExited(true);

    if (props.onExited) {
      props.onExited(...args);
    }
  };

  createEffect(() => {
    if (rootElement()) {
      useRootClose(rootElement, props.onHide, {
        get disabled() {
          return !props.rootClose || props.rootCloseDisabled || !props.show;
        },

        get clickTrigger() {
          return props.rootCloseEvent;
        }

      });
    }
  });
  const wrapperProps = createMemo(() => ({ ...popper()?.attributes.popper,
    style: popper()?.styles.popper,
    ref: attachRef
  }));
  const arrowProps = createMemo(() => ({ ...popper()?.attributes.arrow,
    style: popper()?.styles.arrow,
    ref: attachArrowRef
  }));
  const metadata = createMemo(() => ({
    popper: popper(),
    placement: props.placement,
    show: !!props.show
  }));
  const resolvedChildren = children(() => props.children);

  const InnerChild = () => memo(() => resolvedChildren()(wrapperProps, arrowProps, metadata));

  let Transition;
  return createComponent(Show, {
    get when() {
      return memo(() => !!container())() && popperVisible();
    },

    get children() {
      return createComponent(Portal, {
        get mount() {
          return container();
        },

        get children() {
          return memo(() => !!(Transition = props.transition))() ? createComponent(Transition, {
            appear: true,

            get ["in"]() {
              return props.show;
            },

            get onExit() {
              return props.onExit;
            },

            get onExiting() {
              return props.onExiting;
            },

            onExited: handleHidden,

            get onEnter() {
              return props.onEnter;
            },

            get onEntering() {
              return props.onEntering;
            },

            get onEntered() {
              return props.onEntered;
            },

            get children() {
              return createComponent(InnerChild, {});
            }

          }) : createComponent(InnerChild, {});
        }

      });
    }

  });
};
var Overlay$1 = Overlay;

const defaultProps = {
  role: "tabpanel"
};
function useTabPanel(p) {
  const [local, props] = splitProps(mergeProps(defaultProps, p), ["active", "eventKey", "mountOnEnter", "transition", "unmountOnExit"]);
  const context = useContext(TabContext$1);
  if (!context) return [props, {
    get eventKey() {
      return local.eventKey;
    },

    get isActive() {
      return local.active;
    },

    get mountOnEnter() {
      return local.mountOnEnter;
    },

    get transition() {
      return local.transition;
    },

    get unmountOnExit() {
      return local.unmountOnExit;
    }

  }];
  const key = makeEventKey(local.eventKey);
  const useTabPanel = mergeProps(props, {
    get id() {
      return context?.getControlledId(local.eventKey);
    },

    get "aria-labelledby"() {
      return context?.getControllerId(local.eventKey);
    }

  });
  return [useTabPanel, {
    get eventKey() {
      return local.eventKey;
    },

    get isActive() {
      return local.active == null && key != null ? makeEventKey(context?.activeKey) === key : local.active;
    },

    get transition() {
      return local.transition || context?.transition || NoopTransition$1;
    },

    get mountOnEnter() {
      return local.mountOnEnter != null ? local.mountOnEnter : context?.mountOnEnter;
    },

    get unmountOnExit() {
      return local.unmountOnExit != null ? local.unmountOnExit : context?.unmountOnExit;
    }

  }];
}
const TabPanel = props => {
  const [tabPanelProps, other] = useTabPanel(props);
  other.transition; // We provide an empty the TabContext so `<Nav>`s in `<TabPanel>`s don't
  // conflict with the top level one.

  return createComponent(TabContext$1.Provider, {
    value: null,

    get children() {
      return createComponent(SelectableContext$1.Provider, {
        value: null,

        get children() {
          return createComponent(Dynamic, mergeProps$1({
            get component() {
              return props.as ?? "div";
            }

          }, tabPanelProps, {
            role: "tabpanel",

            get hidden() {
              return !other.isActive;
            },

            get ["aria-hidden"]() {
              return !other.isActive;
            }

          }));
        }

      });
    }

  });
};
var TabPanel$1 = TabPanel;

const Tabs = props => {
  const [activeKey, onSelect] = createControlledProp(() => props.activeKey, () => props.defaultActiveKey, props.onSelect);
  const id = useSSRSafeId(props.id);
  const generateChildId = createMemo(() => props.generateChildId || ((key, type) => id ? `${id}-${type}-${key}` : null));
  const tabContext = {
    get onSelect() {
      return onSelect;
    },

    get activeKey() {
      return activeKey();
    },

    get transition() {
      return props.transition;
    },

    get mountOnEnter() {
      return props.mountOnEnter || false;
    },

    get unmountOnExit() {
      return props.unmountOnExit || false;
    },

    get getControlledId() {
      return key => generateChildId()(key, "pane");
    },

    get getControllerId() {
      return key => generateChildId()(key, "tab");
    }

  };
  return createComponent(TabContext$1.Provider, {
    value: tabContext,

    get children() {
      return createComponent(SelectableContext$1.Provider, {
        value: onSelect || null,

        get children() {
          return props.children;
        }

      });
    }

  });
};
Tabs.Panel = TabPanel$1;
var Tabs$1 = Tabs;

export { Anchor$1 as Anchor, Button$1 as Button, Dropdown, DropdownContext$1 as DropdownContext, DropdownItem$1 as DropdownItem, DropdownMenu, DropdownToggle, Modal$1 as Modal, ModalManager$1 as ModalManager, Nav$1 as Nav, NavItem$1 as NavItem, NoopTransition$1 as NoopTransition, Overlay$1 as Overlay, SelectableContext$1 as SelectableContext, TabContext$1 as TabContext, TabPanel$1 as TabPanel, Tabs$1 as Tabs, callEventHandler, createControlledProp, makeEventKey, resolveClasses, useButtonProps, useDropdownItem, useDropdownMenu, useDropdownToggle, useNavItem, useRootClose, useTabPanel };
